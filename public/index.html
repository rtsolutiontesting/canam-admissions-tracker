<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CANAM IAPPLY - Dashboard</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; overflow-x: hidden; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; display: flex; flex-direction: column; height: 100vh; overflow-x: hidden; }
        /* Top Navigation Bar */
        .top-navbar { background: #1e3a5f; color: white; padding: 0 15px; display: flex; align-items: center; justify-content: space-between; height: 70px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); z-index: 1000; width: 100%; max-width: 100vw; }
        .navbar-left { display: flex; align-items: center; gap: 10px; flex: 1; min-width: 0; }
        .navbar-logo { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 16px; white-space: nowrap; }
        .navbar-logo-icon { width: 28px; height: 28px; background: white; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 18px; color: #1e3a5f; flex-shrink: 0; }
        .navbar-nav { display: flex; gap: 0; flex-wrap: nowrap; }
        .nav-item { padding: 0 12px; height: 70px; display: flex; align-items: center; gap: 6px; cursor: pointer; transition: background 0.2s; border-bottom: 3px solid transparent; white-space: nowrap; font-size: 14px; }
        .nav-item:hover { background: rgba(255,255,255,0.1); }
        .nav-item.active { background: rgba(255,255,255,0.1); border-bottom-color: white; }
        .navbar-right { display: flex; align-items: center; gap: 10px; flex-shrink: 0; }
        .user-profile-compact { display: flex; align-items: center; gap: 12px; }
        .user-avatar { width: 36px; height: 36px; background: white; color: #1e3a5f; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 14px; }
        .user-info-compact { display: flex; flex-direction: column; }
        .user-email { font-size: 12px; font-weight: 600; }
        .user-role { font-size: 10px; color: rgba(255,255,255,0.7); }
        .logout-link { color: rgba(255,255,255,0.8); text-decoration: none; font-size: 12px; padding: 8px 12px; border-radius: 4px; transition: background 0.2s; }
        .logout-link:hover { background: rgba(255,255,255,0.1); color: white; }
        .main-content { flex: 1; display: flex; flex-direction: column; background: #f5f5f5; overflow-y: auto; overflow-x: hidden; width: 100%; max-width: 100vw; }
        .top-bar { padding: 15px 20px; background: white; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .api-status { display: flex; align-items: center; gap: 8px; font-size: 12px; color: #666; white-space: nowrap; }
        .status-dot { width: 6px; height: 6px; background: #4caf50; border-radius: 50%; flex-shrink: 0; }
        .version-info { font-size: 11px; color: #999; white-space: nowrap; }
        .content-area { padding: 0; width: 100%; max-width: 100%; overflow-x: hidden; }
        .action-buttons-top { display: flex; gap: 8px; align-items: center; padding: 12px 20px; background: white; border-bottom: 1px solid #e0e0e0; box-shadow: 0 2px 4px rgba(0,0,0,0.05); flex-wrap: wrap; }
        .main-content-area { width: 100%; padding: 0; }
        .dashboard-title { padding: 20px 20px 0; font-size: 24px; font-weight: 600; color: #333; }
        .dashboard-title { font-size: 24px; font-weight: 600; margin-bottom: 20px; color: #333; }
        .card { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); width: 100%; max-width: 100%; overflow-x: hidden; }
        .card.full-width { margin: 0; border-radius: 0; box-shadow: none; }
        .small-button { padding: 6px 12px; font-size: 11px; font-weight: 600; border: none; border-radius: 4px; cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 4px; transition: all 0.2s; white-space: nowrap; }
        .small-button:hover { transform: translateY(-1px); box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .small-button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .progress-split-container { display: flex; gap: 10px; margin: 20px 0; }
        .progress-half { flex: 1; }
        .progress-half-title { font-size: 11px; font-weight: 600; color: #666; margin-bottom: 5px; text-transform: uppercase; }
        .ai-progress-info { font-size: 10px; color: #666; margin-top: 5px; }
        .nlp-preview-window { background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%); border: 2px solid #2196f3; border-radius: 8px; padding: 15px; max-height: 400px; overflow-y: auto; }
        .nlp-preview-title { font-size: 14px; font-weight: 600; color: #1976d2; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; }
        .nlp-item { padding: 12px; background: white; border-left: 4px solid #2196f3; margin-bottom: 10px; border-radius: 4px; font-size: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .nlp-item.new { border-left-color: #4caf50; background: #f1f8e9; }
        .nlp-item-header { font-weight: 600; color: #1976d2; margin-bottom: 6px; font-size: 13px; }
        .nlp-item-content { color: #424242; font-size: 12px; line-height: 1.5; }
        .nlp-item-content strong { color: #1976d2; }
        .error-preview-window { background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; max-height: 400px; overflow-y: auto; }
        .error-preview-title { font-size: 14px; font-weight: 600; color: #856404; margin-bottom: 10px; display: flex; align-items: center; gap: 8px; }
        .error-item { padding: 8px; background: white; border-left: 3px solid #ff9800; margin-bottom: 8px; border-radius: 4px; font-size: 12px; }
        .error-item-header { font-weight: 600; color: #333; margin-bottom: 4px; }
        .error-item-message { color: #d32f2f; font-size: 11px; }
        .card-title { font-size: 16px; font-weight: 600; color: #333; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 0.5px; }
        .url-input-group { margin-bottom: 20px; }
        .url-label { font-size: 12px; color: #666; margin-bottom: 8px; font-weight: 600; }
        .url-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; }
        .sync-button { width: 100%; padding: 14px; background: #1e3a5f; color: white; border: none; border-radius: 4px; font-size: 15px; font-weight: 600; cursor: pointer; }
        .sync-button:hover { background: #2a4d7a; }
        .sync-button:disabled { background: #ccc; cursor: not-allowed; }
        .legend { display: flex; gap: 20px; margin-bottom: 20px; }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 12px; color: #666; }
        .legend-dot { width: 12px; height: 12px; border-radius: 50%; }
        .legend-dot.changed { background: #2196f3; }
        .legend-dot.new { background: #4caf50; }
        .legend-dot.lost { background: #f44336; }
        #dataTableContainer { width: 100%; overflow-x: auto; overflow-y: visible; -webkit-overflow-scrolling: touch; }
        table { width: 100%; border-collapse: collapse; min-width: 1200px; }
        th { padding: 12px 8px; text-align: left; background: #f8f9fa; font-size: 11px; font-weight: 600; color: #666; text-transform: uppercase; border-bottom: 2px solid #e0e0e0; white-space: nowrap; }
        td { padding: 12px 8px; border-bottom: 1px solid #f0f0f0; font-size: 13px; white-space: nowrap; }
        td:nth-child(1) { min-width: 50px; } /* Sr */
        td:nth-child(2) { min-width: 200px; max-width: 250px; white-space: normal; word-wrap: break-word; } /* universityName */
        td:nth-child(3) { min-width: 100px; } /* Location */
        td:nth-child(4) { min-width: 250px; max-width: 300px; white-space: normal; word-wrap: break-word; } /* programName */
        td:nth-child(5) { min-width: 200px; max-width: 300px; white-space: normal; word-wrap: break-word; } /* admissionsPageUrl */
        td:nth-child(6) { min-width: 120px; } /* intakesAvailable */
        td:nth-child(7) { min-width: 150px; } /* Application Deadline */
        td:nth-child(8) { min-width: 150px; } /* admissionDeadline_found */
        td:nth-child(8) { min-width: 150px; } /* casSubmissionDeadline_found */
        td:nth-child(9) { min-width: 150px; max-width: 200px; white-space: normal; word-wrap: break-word; } /* errorMessage */
        td:nth-child(10) { min-width: 100px; } /* checkedDate */
        td:nth-child(11) { min-width: 150px; max-width: 200px; white-space: normal; word-wrap: break-word; } /* remarks */
        tr:hover { background: #f8f9fa; }
        .status-badge { padding: 4px 12px; border-radius: 12px; font-size: 11px; font-weight: 600; display: inline-block; }
        .status-open { background: #e8f5e9; color: #2e7d32; }
        .status-closed { background: #f5f5f5; color: #616161; }
        .status-pending { background: #fff3e0; color: #e65100; }
        .log-icon { color: #4caf50; font-size: 18px; }
        .execution-stream { min-height: 200px; background: #fafafa; border-radius: 4px; padding: 20px; font-family: 'Courier New', monospace; font-size: 12px; color: #666; }
        .stream-line { margin-bottom: 8px; padding: 4px 0; }
        .stream-line.success { color: #4caf50; }
        .stream-line.error { color: #f44336; }
        .stream-line.info { color: #2196f3; }
        .download-button { padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; transition: background 0.2s; }
        .download-button:hover { background: #45a049; }
        .load-data-button { padding: 12px 20px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; width: 100%; }
        .load-data-button:hover { background: #1976d2; }
        .load-data-button:disabled { background: #ccc; cursor: not-allowed; opacity: 0.6; }
        .auth-button { padding: 12px 20px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; width: 100%; }
        .auth-button:hover { background: #357ae8; }
        .auth-button:disabled { background: #ccc; cursor: not-allowed; opacity: 0.6; }
        .sync-button { padding: 12px 20px; background: #1e3a5f; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; width: 100%; }
        .sync-button:hover { background: #2a4d7a; }
        .sync-button:disabled { background: #ccc; cursor: not-allowed; opacity: 0.6; }
        .progress-container { margin: 20px 0; }
        .progress-bar-wrapper { width: 100%; height: 24px; background: #e0e0e0; border-radius: 12px; overflow: hidden; margin-bottom: 10px; }
        .progress-bar { height: 100%; background: linear-gradient(90deg, #2196f3, #21cbf3); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-size: 12px; font-weight: 600; }
        .progress-text { font-size: 13px; color: #666; margin-top: 5px; }
        .auth-button { padding: 10px 20px; background: #4285f4; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 600; margin-bottom: 15px; }
        .auth-button:hover { background: #357ae8; }
        .auth-status { padding: 10px; background: #e8f5e9; border: 1px solid #4caf50; border-radius: 4px; margin-bottom: 15px; font-size: 13px; color: #2e7d32; }
        /* AI Agent Modal */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center; }
        .modal-overlay.active { display: flex; }
        .modal-content { background: white; border-radius: 8px; padding: 30px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .modal-title { font-size: 20px; font-weight: 600; color: #333; }
        .modal-close { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; }
        .modal-close:hover { color: #333; }
        .api-key-input-group { margin-bottom: 20px; }
        .api-key-label { font-size: 13px; font-weight: 600; color: #666; margin-bottom: 8px; display: block; }
        .api-key-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; font-family: monospace; }
        .api-key-input:focus { outline: none; border-color: #2196f3; }
        .api-key-help { font-size: 11px; color: #999; margin-top: 5px; }
        .ai-provider-toggle { display: flex; gap: 10px; margin-bottom: 20px; }
        .provider-option { flex: 1; padding: 15px; border: 2px solid #ddd; border-radius: 4px; cursor: pointer; text-align: center; transition: all 0.2s; }
        .provider-option:hover { border-color: #2196f3; }
        .provider-option.active { border-color: #2196f3; background: #e3f2fd; }
        .provider-name { font-weight: 600; margin-bottom: 5px; }
        .provider-desc { font-size: 11px; color: #666; }
        .save-button { width: 100%; padding: 14px; background: #2196f3; color: white; border: none; border-radius: 4px; font-size: 15px; font-weight: 600; cursor: pointer; margin-top: 20px; }
        .save-button:hover { background: #1976d2; }
        .ai-status { padding: 10px; border-radius: 4px; margin-top: 15px; font-size: 12px; }
        .ai-status.configured { background: #e8f5e9; color: #2e7d32; border: 1px solid #4caf50; }
        .ai-status.not-configured { background: #fff3e0; color: #e65100; border: 1px solid #ff9800; }
        
        /* Responsive Design */
        @media (max-width: 1400px) {
            .navbar-logo span { display: none; }
            .navbar-logo { gap: 4px; }
            .nav-item { padding: 0 10px; font-size: 13px; }
            .nav-item span:last-child { display: none; }
            .user-info-compact { display: none; }
            .api-status span { display: none; }
            .version-info { display: none; }
        }
        
        @media (max-width: 1200px) {
            .content-area { padding: 15px; }
            .card { padding: 15px; }
            .dashboard-title { font-size: 20px; }
            .top-bar { padding: 10px 15px; }
            .top-navbar { padding: 0 10px; }
            .navbar-nav { gap: 0; }
            .nav-item { padding: 0 8px; }
        }
        
        @media (max-width: 768px) {
            .top-navbar { height: 60px; flex-wrap: wrap; }
            .navbar-left { flex-wrap: wrap; }
            .navbar-nav { order: 3; width: 100%; justify-content: center; margin-top: 5px; }
            .nav-item { height: 50px; padding: 0 15px; }
            .content-area { padding: 10px; }
            .card { padding: 15px; }
            .dashboard-title { font-size: 18px; margin-bottom: 15px; }
            .card-title { font-size: 14px; }
            .url-input { font-size: 13px; padding: 10px; }
            .legend { flex-wrap: wrap; gap: 10px; }
            table { min-width: 1000px; }
            th, td { padding: 10px 6px; font-size: 12px; }
        }
        
        @media (max-width: 480px) {
            .top-navbar { height: auto; min-height: 60px; }
            .navbar-logo-icon { width: 24px; height: 24px; font-size: 16px; }
            .navbar-logo { font-size: 14px; }
            .user-avatar { width: 30px; height: 30px; font-size: 12px; }
            .logout-link { padding: 6px 8px; font-size: 11px; }
            .content-area { padding: 8px; }
            .card { padding: 12px; }
            table { min-width: 900px; }
            th, td { padding: 8px 4px; font-size: 11px; }
        }
    </style>
</head>
<body>
    <!-- Top Navigation Bar -->
    <div class="top-navbar">
        <div class="navbar-left">
            <div class="navbar-logo">
                <div class="navbar-logo-icon">üèõÔ∏è</div>
                <span>CANAM IAPPLY</span>
            </div>
            <div class="navbar-nav">
                <div class="nav-item active">
                    <span class="nav-icon">üìä</span>
                    <span>Dashboard</span>
                </div>
                <div class="nav-item" onclick="window.location.href='/scheduler.html'" style="cursor: pointer;">
                    <span class="nav-icon">‚è∞</span>
                    <span>Scheduler</span>
                </div>
                <div class="nav-item" onclick="showAIAgentConfig()" style="cursor: pointer;">
                    <span class="nav-icon">ü§ñ</span>
                    <span>Use AI Agent</span>
                </div>
            </div>
        </div>
        <div class="navbar-right">
            <div class="api-status" style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                <div class="status-dot" style="width: 6px; height: 6px; background: #4caf50; border-radius: 50%;"></div>
                <span>Google API: Authorized</span>
            </div>
            <div class="user-profile-compact">
                <div class="user-avatar" id="userAvatar">A</div>
                <div class="user-info-compact">
                    <div class="user-email" id="userEmail">admin@canamiapply.com</div>
                    <div class="user-role">ADMIN</div>
                </div>
            </div>
            <a href="#" class="logout-link" onclick="logout(); return false;">Logout</a>
            <div class="version-info" style="font-size: 11px; color: rgba(255,255,255,0.7);">v2.5.0</div>
        </div>
    </div>
    <div class="main-content">
        <div class="top-bar">
            <div class="dashboard-title" style="margin: 0; font-size: 24px;">Dashboard</div>
            <div style="display: flex; align-items: center; gap: 20px;">
                <div class="version-info">By RT</div>
            </div>
        </div>
        <div class="content-area">
            <!-- Action Buttons at Top -->
            <div class="action-buttons-top">
                <div style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 200px;">
                    <div style="font-size: 11px; font-weight: 600; color: #666; white-space: nowrap;">SHEET URL:</div>
                    <input type="text" class="url-input" id="sheetUrl" value="https://docs.google.com/spreadsheets/d/1txotdjDo6EctNnP44" placeholder="Google Sheet URL" style="flex: 1; font-size: 11px; padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; min-width: 200px;">
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input type="file" id="excelFileInput" accept=".xlsx,.xls,.csv" style="display: none;" onchange="document.getElementById('excelFileName').textContent = this.files[0]?.name || 'No file chosen'">
                    <label for="excelFileInput" class="small-button" style="background: #f5f5f5; color: #666; cursor: pointer; margin: 0;">
                        üìÅ Choose File
                    </label>
                    <span id="excelFileName" style="font-size: 11px; color: #999; min-width: 100px;">No file chosen</span>
                    <button class="small-button" id="uploadExcelButton" onclick="uploadExcelFile()" style="background: #2196f3; color: white; margin: 0;">
                        üì§ Upload & Load
                    </button>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <button class="small-button" id="authGoogleButton" onclick="authorizeGoogleDrive()" style="background: #4285f4; color: white; margin: 0;">
                        üîê Authorize Drive
                    </button>
                    <div id="authStatusDiv" style="display: none; padding: 4px 8px; background: #e8f5e9; border-radius: 4px; color: #2e7d32; font-size: 10px;">
                        ‚úÖ Authorized
                    </div>
                    <button class="small-button" id="loadDataButton" onclick="loadDataFromSheet()" disabled style="background: #666; color: white; margin: 0;">üì• Load Data</button>
                    <button class="small-button" id="authButton" onclick="handleAuthClick()" disabled style="display: none; background: #4285f4; color: white; margin: 0;">üîê Auth Sheets</button>
                    <button class="small-button" id="syncButton" onclick="runManualSync()" disabled style="background: #1e3a5f; color: white; margin: 0;">‚ñ∂Ô∏è Sync Now</button>
                </div>
            </div>
            
            <!-- Progress Bars -->
            <div class="progress-split-container" id="progressContainer" style="display: none; margin-bottom: 20px;">
                <div class="progress-half">
                    <div class="progress-half-title">Overall Progress</div>
                    <div class="progress-bar-wrapper" style="height: 20px;">
                        <div class="progress-bar" id="progressBar" style="width: 0%; font-size: 10px;">0%</div>
                    </div>
                    <div class="progress-text" id="progressText" style="font-size: 10px;">Initializing...</div>
                </div>
                <div class="progress-half">
                    <div class="progress-half-title">AI Usage</div>
                    <div class="progress-bar-wrapper" style="height: 20px; background: #e8f5e9;">
                        <div class="progress-bar" id="aiProgressBar" style="width: 0%; background: linear-gradient(90deg, #4caf50, #8bc34a); font-size: 10px;">0%</div>
                    </div>
                    <div class="ai-progress-info" id="aiProgressInfo">Not using AI</div>
                </div>
            </div>
            
            <!-- Main Content - Full Width Edge-to-Edge -->
            <div class="main-content-area" style="width: 100%; padding: 0;">
                <div class="dashboard-title" style="padding: 20px 20px 0;">Dashboard</div>
                
                <!-- Master Data Preview - Edge to Edge -->
                <div class="card" style="margin: 0; border-radius: 0; box-shadow: none; border-top: 1px solid #e0e0e0; padding: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; gap: 20px;">
                            <div class="card-title" style="margin: 0;">MASTER DATA PREVIEW</div>
                            <div class="legend">
                                <div class="legend-item"><div class="legend-dot changed"></div><span>CHANGED</span></div>
                                <div class="legend-item"><div class="legend-dot new"></div><span>NEW</span></div>
                                <div class="legend-item"><div class="legend-dot lost"></div><span>LOST</span></div>
                            </div>
                        </div>
                        <button class="download-button" onclick="downloadCSV()">üì• Download CSV</button>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 350px; gap: 20px; align-items: start;">
                        <div style="min-width: 0; overflow-x: auto;">
                            <div id="dataTableContainer" style="width: 100%; overflow-x: auto;">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Sr</th>
                                            <th>universityName</th>
                                            <th>Campus Location</th>
                                            <th>programName</th>
                                            <th>admissionsPageUrl</th>
                                            <th>intakesAvailable</th>
                                            <th>Application Deadline</th>
                                            <th>admissionDeadline_found</th>
                                            <th>casSubmissionDeadline_found</th>
                                            <th>i20Deadline_found</th>
                                            <th>intakeStatus</th>
                                            <th>errorMessage</th>
                                            <th>checkedDate</th>
                                            <th>remarks</th>
                                        </tr>
                                    </thead>
                                    <tbody id="dataTableBody">
                                        <tr><td colspan="12" style="text-align: center; padding: 40px;">No data available. Run sync to load programs.</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <div style="flex-shrink: 0;">
                            <div class="nlp-preview-window" id="nlpPreviewWindow" style="max-height: calc(100vh - 300px); position: sticky; top: 20px;">
                                <div class="nlp-preview-title" style="display: flex; justify-content: space-between; align-items: center;">
                                    <span>ü§ñ NLP Preview - What We're Reading</span>
                                    <span id="nlpItemCount" style="background: #2196f3; color: white; padding: 2px 8px; border-radius: 10px; font-size: 10px;">0</span>
                                </div>
                                <div id="nlpPreviewContent" style="font-size: 11px; color: #666;">
                                    <div style="text-align: center; padding: 20px; color: #999;">
                                        <div style="font-size: 24px; margin-bottom: 8px;">üìñ</div>
                                        <div>Ready to read and understand web pages...</div>
                                        <div style="font-size: 10px; margin-top: 8px; color: #999;">Natural language insights will appear here as we scan each program page</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Live Stream Summary - Edge to Edge -->
                <div class="card" style="margin: 0; border-radius: 0; border-top: 1px solid #e0e0e0; box-shadow: none; padding: 20px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <div class="card-title" style="color: white; margin-bottom: 20px;">üìä LIVE STREAM SUMMARY</div>
                    <div class="summary-grid" id="summaryGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div class="summary-card">
                            <div class="summary-label">Total URL Scanned</div>
                            <div class="summary-value" id="statUrlsScanned" data-target="0">0</div>
                        </div>
                        <div class="summary-card">
                            <div class="summary-label">Total Programs Found</div>
                            <div class="summary-value" id="statProgramsFound" data-target="0">0</div>
                        </div>
                        <div class="summary-card">
                            <div class="summary-label">Total Intakes Found</div>
                            <div class="summary-value" id="statIntakesFound" data-target="0">0</div>
                        </div>
                        <div class="summary-card">
                            <div class="summary-label">Total Deadlines Found</div>
                            <div class="summary-value" id="statDeadlinesFound" data-target="0">0</div>
                        </div>
                        <div class="summary-card">
                            <div class="summary-label">Total Remarks Found</div>
                            <div class="summary-value" id="statRemarksFound" data-target="0">0</div>
                        </div>
                        <div class="summary-card error-card">
                            <div class="summary-label">URLs Blocked</div>
                            <div class="summary-value" id="statUrlsBlocked" data-target="0">0</div>
                        </div>
                        <div class="summary-card error-card">
                            <div class="summary-label">Error Messages</div>
                            <div class="summary-value" id="statErrorMessages" data-target="0">0</div>
                        </div>
                    </div>
                </div>
                
                <!-- Live Execution Stream - Edge to Edge -->
                <div class="card" style="margin: 0; border-radius: 0; border-top: 1px solid #e0e0e0; box-shadow: none; padding: 20px;">
                    <div class="card-title">LIVE EXECUTION STREAM</div>
                    <div class="execution-stream" id="executionStream">
                        <div class="stream-line info">Waiting for execution...</div>
                    </div>
                </div>
            </div>
    </div>
    
    <!-- AI Agent Configuration Modal -->
    <div class="modal-overlay" id="aiAgentModal" onclick="if(event.target.id === 'aiAgentModal') closeAIAgentConfig()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="modal-title">ü§ñ AI Agent Configuration</div>
                <button class="modal-close" onclick="closeAIAgentConfig()">&times;</button>
            </div>
            <div style="margin-bottom: 20px;">
                <p style="font-size: 13px; color: #666; margin-bottom: 15px;">
                    Configure AI agents to extract data when direct fetching fails. AI agents can read and extract information from any webpage, bypassing CORS restrictions.
                </p>
                <div class="ai-provider-toggle">
                    <div class="provider-option active" id="geminiOption" onclick="selectProvider('gemini')">
                        <div class="provider-name">Google Gemini</div>
                        <div class="provider-desc">Free tier available</div>
                    </div>
                    <div class="provider-option" id="openaiOption" onclick="selectProvider('openai')">
                        <div class="provider-name">OpenAI GPT</div>
                        <div class="provider-desc">Paid service</div>
                    </div>
                </div>
            </div>
            <div class="api-key-input-group">
                <label class="api-key-label" id="apiKeyLabel">Google Gemini API Key</label>
                <input type="password" class="api-key-input" id="geminiApiKey" placeholder="Enter your Gemini API key">
                <div class="api-key-help">
                    Get your API key from: <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a>
                </div>
            </div>
            <div class="api-key-input-group" id="openaiKeyGroup" style="display: none;">
                <label class="api-key-label">OpenAI API Key</label>
                <input type="password" class="api-key-input" id="openaiApiKey" placeholder="Enter your OpenAI API key">
                <div class="api-key-help">
                    Get your API key from: <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Platform</a>
                </div>
            </div>
            <div id="aiStatusDiv" class="ai-status not-configured">
                ‚ö†Ô∏è AI Agent not configured. Configure API keys to enable AI-powered extraction.
            </div>
            <button class="save-button" onclick="saveAIAgentConfig()">üíæ Save Configuration</button>
            <div style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px; font-size: 12px; color: #666;">
                <strong>How it works:</strong><br>
                1. When direct fetch fails due to CORS, the system automatically uses AI agent<br>
                2. AI agent fetches the page content and extracts structured data<br>
                3. Returns admission deadlines, CAS deadlines, intakes, and other information<br>
                4. More reliable than pattern matching and works with any website structure
            </div>
        </div>
    </div>
    
    <!-- AI Configuration Functions - Must be in non-module script for onclick handlers -->
    <script>
        // AI Agent Configuration - Global functions for modal
        let aiProvider = 'gemini';
        let geminiApiKey = null;
        let openaiApiKey = null;
        
        // Load AI configuration from localStorage
        function loadAIConfigGlobal() {
            try {
                aiProvider = localStorage.getItem('aiProvider') || 'gemini';
                geminiApiKey = localStorage.getItem('geminiApiKey') || null;
                openaiApiKey = localStorage.getItem('openaiApiKey') || null;
                updateAIStatusGlobal();
                console.log('AI Config loaded:', { aiProvider, hasGeminiKey: !!geminiApiKey, hasOpenAIKey: !!openaiApiKey });
            } catch (error) {
                console.error('Error loading AI config:', error);
            }
        }
        
        // Save AI configuration
        window.saveAIAgentConfig = function() {
            try {
                const geminiInput = document.getElementById('geminiApiKey');
                const openaiInput = document.getElementById('openaiApiKey');
                
                if (!geminiInput || !openaiInput) {
                    alert('Error: Could not find API key input fields');
                    return;
                }
                
                const geminiKey = geminiInput.value.trim();
                const openaiKey = openaiInput.value.trim();
                
                if (aiProvider === 'gemini' && !geminiKey) {
                    alert('Please enter your Gemini API key');
                    return;
                }
                if (aiProvider === 'openai' && !openaiKey) {
                    alert('Please enter your OpenAI API key');
                    return;
                }
                
                // Save to localStorage
                localStorage.setItem('aiProvider', aiProvider);
                if (geminiKey) {
                    localStorage.setItem('geminiApiKey', geminiKey);
                } else {
                    localStorage.removeItem('geminiApiKey');
                }
                if (openaiKey) {
                    localStorage.setItem('openaiApiKey', openaiKey);
                } else {
                    localStorage.removeItem('openaiApiKey');
                }
                
                // Update variables
                geminiApiKey = geminiKey || null;
                openaiApiKey = openaiKey || null;
                
                console.log('AI Config saved:', { aiProvider, hasGeminiKey: !!geminiApiKey, hasOpenAIKey: !!openaiApiKey });
                
                updateAIStatusGlobal();
                
                // Show success message
                const statusDiv = document.getElementById('aiStatusDiv');
                if (statusDiv) {
                    statusDiv.className = 'ai-status configured';
                    statusDiv.textContent = `‚úÖ AI Agent configured (${aiProvider === 'gemini' ? 'Google Gemini' : 'OpenAI'})`;
                }
                
                // Try to call addStreamLine if available (from module script)
                if (typeof window.addStreamLine === 'function') {
                    window.addStreamLine('success', `‚úÖ AI Agent configuration saved successfully! Using ${aiProvider === 'gemini' ? 'Google Gemini' : 'OpenAI'}`);
                }
                
                closeAIAgentConfig();
            } catch (error) {
                console.error('Error saving AI config:', error);
                alert('Error saving configuration: ' + error.message);
            }
        };
        
        // Show AI Agent configuration modal
        window.showAIAgentConfig = function() {
            loadAIConfigGlobal();
            const modal = document.getElementById('aiAgentModal');
            if (!modal) {
                console.error('AI Agent modal not found');
                return;
            }
            const geminiInput = document.getElementById('geminiApiKey');
            const openaiInput = document.getElementById('openaiApiKey');
            if (geminiInput) geminiInput.value = geminiApiKey || '';
            if (openaiInput) openaiInput.value = openaiApiKey || '';
            selectProvider(aiProvider);
            modal.classList.add('active');
        };
        
        // Close AI Agent configuration modal
        window.closeAIAgentConfig = function() {
            const modal = document.getElementById('aiAgentModal');
            if (modal) {
                modal.classList.remove('active');
            }
        };
        
        // Select AI provider
        window.selectProvider = function(provider) {
            aiProvider = provider;
            const geminiOption = document.getElementById('geminiOption');
            const openaiOption = document.getElementById('openaiOption');
            const openaiKeyGroup = document.getElementById('openaiKeyGroup');
            const apiKeyLabel = document.getElementById('apiKeyLabel');
            
            if (geminiOption) geminiOption.classList.toggle('active', provider === 'gemini');
            if (openaiOption) openaiOption.classList.toggle('active', provider === 'openai');
            if (openaiKeyGroup) openaiKeyGroup.style.display = provider === 'openai' ? 'block' : 'none';
            if (apiKeyLabel) apiKeyLabel.textContent = provider === 'gemini' ? 'Google Gemini API Key' : 'OpenAI API Key';
        };
        
        // Update AI status display
        function updateAIStatusGlobal() {
            const statusDiv = document.getElementById('aiStatusDiv');
            if (!statusDiv) return;
            
            const hasKey = (aiProvider === 'gemini' && geminiApiKey) || (aiProvider === 'openai' && openaiApiKey);
            if (hasKey) {
                statusDiv.className = 'ai-status configured';
                statusDiv.textContent = `‚úÖ AI Agent configured (${aiProvider === 'gemini' ? 'Google Gemini' : 'OpenAI'})`;
            } else {
                statusDiv.className = 'ai-status not-configured';
                statusDiv.textContent = '‚ö†Ô∏è AI Agent not configured. Configure API keys to enable AI-powered extraction.';
            }
        }
        
        // Load config on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadAIConfigGlobal();
        });
        
        // Make config available to module script
        window.getAIConfig = function() {
            return {
                aiProvider: aiProvider,
                geminiApiKey: geminiApiKey,
                openaiApiKey: openaiApiKey
            };
        };
        
        // Allow module script to update config
        window.setAIConfig = function(config) {
            aiProvider = config.aiProvider || aiProvider;
            geminiApiKey = config.geminiApiKey !== undefined ? config.geminiApiKey : geminiApiKey;
            openaiApiKey = config.openaiApiKey !== undefined ? config.openaiApiKey : openaiApiKey;
            updateAIStatusGlobal();
        };
    </script>

    <!-- Upload Excel File Function - Must be global for onclick handler -->
    <script>
        // Upload and process Excel file - Global function for onclick handler
        window.uploadExcelFile = async function() {
            const fileInput = document.getElementById('excelFileInput');
            const uploadButton = document.getElementById('uploadExcelButton');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const tbody = document.getElementById('dataTableBody');

            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select an Excel file to upload');
                return;
            }

            const file = fileInput.files[0];
            const fileName = file.name;

            try {
                uploadButton.disabled = true;
                progressContainer.style.display = 'block';
                tbody.innerHTML = '<tr><td colspan="13" style="text-align: center; padding: 20px;">Loading data...</td></tr>';

                // Use window functions (exposed from module script)
                const updateProgressFn = window.updateProgress || (() => {});
                const addStreamLineFn = window.addStreamLine || (() => {});
                
                updateProgressFn(10, 'Reading Excel file...');
                addStreamLineFn('info', `Uploading file: ${fileName}`);

                // Read file as ArrayBuffer
                const arrayBuffer = await file.arrayBuffer();
                updateProgressFn(30, 'Parsing Excel data...');
                addStreamLineFn('info', 'Parsing Excel file...');

                // Check if XLSX library is loaded
                if (typeof XLSX === 'undefined') {
                    throw new Error('Excel parser library not loaded. Please refresh the page.');
                }

                // Parse Excel file using SheetJS
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const firstSheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[firstSheetName];
                
                // Convert to JSON array (array of arrays)
                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                
                if (!jsonData || jsonData.length === 0) {
                    throw new Error('Excel file is empty or could not be parsed');
                }

                updateProgressFn(50, 'Processing data...');
                addStreamLineFn('success', `‚úÖ Excel file parsed! Found ${jsonData.length} rows`);
                addStreamLineFn('info', `Sheet name: ${firstSheetName}`);

                // Process data using shared function (will be called from module script)
                // We need to call the processSheetData function from the module scope
                if (typeof window.processSheetData === 'function') {
                    await window.processSheetData(jsonData, 'excel');
                } else {
                    // Fallback: basic processing
                    addStreamLineFn('warning', 'Advanced processing not available. Using basic mode.');
                    // Basic processing will be handled by the module script
                }

                // Mark as loaded - update both module and window references
                // The processSheetData function should have already set sheetDataLoaded, but ensure it's set
                if (window.sheetDataLoaded !== undefined) {
                    window.sheetDataLoaded = true;
                }
                // Also update the module variable directly if accessible
                if (typeof window.setSheetDataLoaded === 'function') {
                    window.setSheetDataLoaded(true);
                }
                if (window.currentSpreadsheetId !== undefined) {
                    window.currentSpreadsheetId = `excel_${fileName}`;
                }
                // Use window function (exposed from module script)
                if (typeof window.updateButtonStates === 'function') {
                    window.updateButtonStates();
                }
                
                // Double-check sync button is enabled
                const syncButton = document.getElementById('syncButton');
                if (syncButton && window.programDataStore && window.programDataStore.length > 0) {
                    syncButton.disabled = false;
                    addStreamLineFn('info', 'Sync Now button enabled. Ready to sync!');
                }

                // Access programDataStore from window (exposed from module script)
                const programDataStoreRef = window.programDataStore || [];
                updateProgressFn(100, `‚úÖ Loaded ${programDataStoreRef.length} programs from Excel`);
                addStreamLineFn('success', `‚úÖ Step 1 Complete: Loaded ${programDataStoreRef.length} programs from Excel file`);
                addStreamLineFn('info', 'You can now proceed to Step 3: Sync Now');

            } catch (error) {
                console.error('Excel upload error:', error);
                addStreamLineFn('error', `Excel upload failed: ${error.message}`);
                alert(`Failed to upload Excel file: ${error.message}`);
                updateProgressFn(0, 'Upload failed');
            } finally {
                uploadButton.disabled = false;
                setTimeout(() => {
                    if (progressContainer) progressContainer.style.display = 'none';
                }, 3000);
            }
        };
    </script>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getAuth, onAuthStateChanged, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        const firebaseConfig = {
            apiKey: "AIzaSyD9L38LMVnlwRn3njGCamnj8fBXvh_601I",
            authDomain: "programinfo-603ec.firebaseapp.com",
            projectId: "programinfo-603ec",
            storageBucket: "programinfo-603ec.firebasestorage.app",
            messagingSenderId: "238141381016",
            appId: "1:238141381016:web:27f10baf9b8f7208ef33ed",
            measurementId: "G-RMW41YRN56"
        };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        let authInitialized = false;
        onAuthStateChanged(auth, (user) => {
            if (authInitialized) return;
            authInitialized = true;
            if (user) {
                updateUserProfile(user);
            } else {
                console.log('User not authenticated. Please visit /login.html to login.');
                const contentArea = document.querySelector('.content-area');
                if (contentArea) {
                    const msg = document.createElement('div');
                    msg.style.cssText = 'padding: 20px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; margin: 20px; color: #856404;';
                    msg.innerHTML = '‚ö†Ô∏è <strong>Not authenticated.</strong> Please <a href="/login.html" style="color: #0066cc;">click here to login</a> or visit <code>/login.html</code> directly.';
                    contentArea.insertBefore(msg, contentArea.firstChild);
                }
            }
        });
        function updateUserProfile(user) {
            const avatar = document.getElementById('userAvatar');
            const email = document.getElementById('userEmail');
            const initial = user.email ? user.email.charAt(0).toUpperCase() : 'A';
            avatar.textContent = initial;
            email.textContent = user.email || 'admin@canamiapply.com';
        }
        window.logout = async function() {
            try {
                await signOut(auth);
                window.location.replace('/login.html');
            } catch (error) {
                console.error('Logout error:', error);
                alert('Logout failed. Please try again.');
            }
        };
        // Statistics tracking
        let syncStats = {
            urlsScanned: 0,
            programsFound: 0,
            intakesFound: 0,
            deadlinesFound: 0,
            remarksFound: 0,
            urlsBlocked: 0,
            errorMessages: 0
        };
        
        // Update statistics with animation
        function updateStat(statId, value) {
            const element = document.getElementById(statId);
            if (!element) return;
            
            const currentValue = parseInt(element.textContent) || 0;
            const targetValue = value;
            
            if (currentValue === targetValue) return;
            
            element.classList.add('updating');
            animateValue(element, currentValue, targetValue, 500);
            element.setAttribute('data-target', targetValue);
            
            setTimeout(() => {
                element.classList.remove('updating');
            }, 500);
        }
        
        // Animate number counting
        function animateValue(element, start, end, duration) {
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    current = end;
                    clearInterval(timer);
                }
                element.textContent = Math.floor(current);
            }, 16);
        }
        
        // Reset statistics
        function resetStats() {
            syncStats = {
                urlsScanned: 0,
                programsFound: 0,
                intakesFound: 0,
                deadlinesFound: 0,
                remarksFound: 0,
                urlsBlocked: 0,
                errorMessages: 0
            };
            updateStat('statUrlsScanned', 0);
            updateStat('statProgramsFound', 0);
            updateStat('statIntakesFound', 0);
            updateStat('statDeadlinesFound', 0);
            updateStat('statRemarksFound', 0);
            updateStat('statUrlsBlocked', 0);
            updateStat('statErrorMessages', 0);
        }
        
        function addStreamLine(type, message) {
            const stream = document.getElementById('executionStream');
            const timestamp = new Date().toLocaleTimeString();
            const line = document.createElement('div');
            line.className = `stream-line ${type}`;
            line.textContent = `[${timestamp}] ${message}`;
            stream.appendChild(line);
            stream.scrollTop = stream.scrollHeight;
        }
        
        // Expose to window for global script access
        window.addStreamLine = addStreamLine;
        let programDataStore = [];
        
        // Expose programDataStore and state variables to window for global script access
        Object.defineProperty(window, 'programDataStore', {
            get: () => programDataStore,
            set: (value) => { programDataStore = value; },
            enumerable: true,
            configurable: true
        });

        // State management
        let sheetDataLoaded = false;
        let googleSheetsAuthenticated = false;
        let currentSpreadsheetId = null;
        let googleAccessToken = null;
        
        // Expose state variables to window for global script access
        Object.defineProperty(window, 'sheetDataLoaded', {
            get: () => sheetDataLoaded,
            set: (value) => { 
                sheetDataLoaded = value; 
                // Auto-update button states when sheetDataLoaded changes
                if (typeof updateButtonStates === 'function') {
                    updateButtonStates();
                }
            },
            enumerable: true,
            configurable: true
        });
        
        // Helper function to set sheetDataLoaded and update buttons
        window.setSheetDataLoaded = function(value) {
            sheetDataLoaded = value;
            updateButtonStates();
        };
        
        Object.defineProperty(window, 'currentSpreadsheetId', {
            get: () => currentSpreadsheetId,
            set: (value) => { currentSpreadsheetId = value; },
            enumerable: true,
            configurable: true
        });
        
        // AI Agent Configuration - Use global config from non-module script
        function getAIConfig() {
            if (typeof window.getAIConfig === 'function') {
                return window.getAIConfig();
            }
            // Fallback if global config not available
            return {
                aiProvider: localStorage.getItem('aiProvider') || 'gemini',
                geminiApiKey: localStorage.getItem('geminiApiKey') || null,
                openaiApiKey: localStorage.getItem('openaiApiKey') || null
            };
        }
        
        // AI-powered extraction using Gemini or OpenAI
        async function extractWithAI(htmlContent, programName, universityName, url) {
            const config = getAIConfig();
            const provider = config.aiProvider;
            const apiKey = provider === 'gemini' ? config.geminiApiKey : config.openaiApiKey;
            
            if (!apiKey) {
                throw new Error('AI API key not configured');
            }
            
            // If HTML content not provided or too short, fetch it via Cloudflare Function proxy
            let contentToExtract = htmlContent;
            
            if (!contentToExtract || contentToExtract.length < 100) {
                // Fetch HTML via Cloudflare Function (server-side, no CORS)
                try {
                    const proxyFunctionUrl = `/api/proxy?url=${encodeURIComponent(url)}`;
                    const proxyResponse = await fetch(proxyFunctionUrl, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache'
                    });
                    
                    if (proxyResponse.ok) {
                        contentToExtract = await proxyResponse.text();
                        if (!contentToExtract || contentToExtract.length < 100) {
                            throw new Error('Proxy returned insufficient content');
                        }
                    } else {
                        throw new Error(`Proxy function returned HTTP ${proxyResponse.status}`);
                    }
                } catch (fetchError) {
                    // If proxy also fails, we'll still try AI with URL context
                    contentToExtract = `URL: ${url}\n\nUnable to fetch HTML content. Please extract information based on the URL and context provided.`;
                }
            }
            
            // Clean HTML content (limit to 50KB for API)
            const cleanHtml = contentToExtract
                .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, ' ')
                .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, ' ')
                .substring(0, 50000);
            
            if (provider === 'gemini') {
                return await extractWithGemini(cleanHtml, programName, universityName, url, apiKey);
            } else {
                return await extractWithOpenAI(cleanHtml, programName, universityName, url, apiKey);
            }
        }
        
        // Extract using Google Gemini
        async function extractWithGemini(htmlContent, programName, universityName, url, apiKey) {
            // Always use HTML content (we fetch it via proxy if needed)
            const prompt = `Extract university admissions information from the following HTML content. Return ONLY valid JSON (no markdown, no explanations):

{
  "admissionDeadline": "YYYY-MM-DD or NOT_FOUND",
  "casDeadline": "YYYY-MM-DD or NOT_FOUND",
  "i20Deadline": "YYYY-MM-DD or NOT_FOUND",
  "intakesAvailable": "e.g., September 2024, Fall 2024 or NOT_FOUND",
  "intakeStatus": "open/closed/waitlist/NOT_FOUND",
  "campusLocation": "campus name or location (e.g., 'Cambridge Campus', 'London Campus', 'New York Campus') or NOT_FOUND",
  "remarks": "any important notes or NOT_FOUND",
  "multiplePrograms": [{"programName": "name", "campusLocation": "location", "admissionDeadline": "date", "casDeadline": "date", "i20Deadline": "date", "intakesAvailable": "intakes", "intakeStatus": "status"}],
  "multipleCampuses": [{"campusLocation": "location", "admissionDeadline": "date", "casDeadline": "date", "i20Deadline": "date", "intakesAvailable": "intakes", "intakeStatus": "status"}]
}

University: ${universityName}
Program: ${programName}
URL: ${url}

HTML Content:
${htmlContent.substring(0, 30000)}

Rules:
1. Return ONLY the JSON object
2. Dates must be in YYYY-MM-DD format
3. If information not found, use "NOT_FOUND"
4. Extract campus location from page (look for "campus", "location", address, city names)
5. Extract intakes from text (e.g., "September 2024", "Fall 2024", "2024/25")
6. Look for deadlines near keywords like "deadline", "closing date", "application closes"
7. Check intake status: "open", "closed", "waitlist", or "NOT_FOUND"
8. Check tabs, dropdowns, and hidden content for information
9. If page has multiple programs or campuses, populate multiplePrograms or multipleCampuses arrays
10. Parse dates in various formats and convert to YYYY-MM-DD`;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: prompt
                            }]
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Gemini API error: ${response.status}`);
                }
                
                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                // Extract JSON from response
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('No JSON found in Gemini response');
                }
                
                const extracted = JSON.parse(jsonMatch[0]);
                return {
                    admissionDeadline: extracted.admissionDeadline || 'NOT_FOUND',
                    casDeadline: extracted.casDeadline || 'NOT_FOUND',
                    intakesAvailable: extracted.intakesAvailable || 'NOT_FOUND',
                    intakeStatus: extracted.intakeStatus || 'NOT_FOUND',
                    remarks: extracted.remarks || '',
                    errorMessage: ''
                };
            } catch (error) {
                throw new Error(`Gemini extraction failed: ${error.message}`);
            }
        }
        
        // Extract using OpenAI GPT
        async function extractWithOpenAI(htmlContent, programName, universityName, url, apiKey) {
            const prompt = `Extract university admissions information from the following HTML content. Return ONLY valid JSON (no markdown, no explanations):

{
  "admissionDeadline": "YYYY-MM-DD or NOT_FOUND",
  "casDeadline": "YYYY-MM-DD or NOT_FOUND",
  "i20Deadline": "YYYY-MM-DD or NOT_FOUND",
  "intakesAvailable": "e.g., September 2024, Fall 2024 or NOT_FOUND",
  "intakeStatus": "open/closed/waitlist/NOT_FOUND",
  "campusLocation": "campus name or location (e.g., 'Cambridge Campus', 'London Campus', 'New York Campus') or NOT_FOUND",
  "remarks": "any important notes or NOT_FOUND",
  "multiplePrograms": [{"programName": "name", "campusLocation": "location", "admissionDeadline": "date", "casDeadline": "date", "i20Deadline": "date", "intakesAvailable": "intakes", "intakeStatus": "status"}],
  "multipleCampuses": [{"campusLocation": "location", "admissionDeadline": "date", "casDeadline": "date", "i20Deadline": "date", "intakesAvailable": "intakes", "intakeStatus": "status"}]
}

University: ${universityName}
Program: ${programName}
URL: ${url}

HTML Content:
${htmlContent.substring(0, 30000)}

Rules:
1. Return ONLY the JSON object
2. Dates must be in YYYY-MM-DD format
3. If information not found, use "NOT_FOUND"
4. Extract campus location from page (look for "campus", "location", address, city names)
5. Extract intakes from text (e.g., "September 2024", "Fall 2024", "2024/25")
6. Look for deadlines near keywords like "deadline", "closing date", "application closes"
7. Check intake status: "open", "closed", "waitlist", or "NOT_FOUND"
8. If page has multiple programs or campuses, populate multiplePrograms or multipleCampuses arrays`;

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-4o-mini',
                        messages: [{
                            role: 'user',
                            content: prompt
                        }],
                        temperature: 0.1,
                        response_format: { type: 'json_object' }
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`OpenAI API error: ${errorData.error?.message || response.status}`);
                }
                
                const data = await response.json();
                const text = data.choices[0].message.content;
                
                // Extract JSON from response
                const jsonMatch = text.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('No JSON found in OpenAI response');
                }
                
                const extracted = JSON.parse(jsonMatch[0]);
                return {
                    admissionDeadline: extracted.admissionDeadline || 'NOT_FOUND',
                    casDeadline: extracted.casDeadline || 'NOT_FOUND',
                    intakesAvailable: extracted.intakesAvailable || 'NOT_FOUND',
                    intakeStatus: extracted.intakeStatus || 'NOT_FOUND',
                    remarks: extracted.remarks || '',
                    errorMessage: ''
                };
            } catch (error) {
                throw new Error(`OpenAI extraction failed: ${error.message}`);
            }
        }
        
        // Load AI config on page load
        // AI config is loaded by global script, no need to load here
        
        // Google OAuth Configuration
        // User needs to set their OAuth Client ID
        // Get it from: https://console.cloud.google.com/apis/credentials
        const GOOGLE_OAUTH_CLIENT_ID = '278548161456-f52u17n3e4pr413hsbprrrom61ghggeo.apps.googleusercontent.com';

        // Extract spreadsheet ID helper
        function extractSpreadsheetId(url) {
            if (!url) return null;
            const match = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            return match ? match[1] : null;
        }

        // Google OAuth 2.0 Authorization
        window.authorizeGoogleDrive = async function() {
            const authButton = document.getElementById('authGoogleButton');
            const authStatusDiv = document.getElementById('authStatusDiv');
            
            if (!GOOGLE_OAUTH_CLIENT_ID || GOOGLE_OAUTH_CLIENT_ID === 'YOUR_OAUTH_CLIENT_ID_HERE') {
                alert('Please configure Google OAuth Client ID first!\n\n1. Go to: https://console.cloud.google.com/apis/credentials\n2. Create OAuth 2.0 Client ID (Web application)\n3. Add authorized JavaScript origins: ' + window.location.origin + '\n4. Update GOOGLE_OAUTH_CLIENT_ID in the code');
                addStreamLine('error', 'OAuth Client ID not configured. Please set it up first.');
                return;
            }

            try {
                authButton.disabled = true;
                authButton.textContent = '‚è≥ Authorizing...';
                addStreamLine('info', 'Starting Google Drive authorization...');

                // Initialize Google Identity Services
                await new Promise((resolve) => {
                    if (window.google && window.google.accounts) {
                        resolve();
                    } else {
                        window.onGoogleLibraryLoad = resolve;
                    }
                });

                // Request OAuth token
                const tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_OAUTH_CLIENT_ID,
                    scope: 'https://www.googleapis.com/auth/spreadsheets.readonly https://www.googleapis.com/auth/drive.readonly',
                    callback: (response) => {
                        if (response.error) {
                            addStreamLine('error', `Authorization failed: ${response.error}`);
                            authButton.disabled = false;
                            authButton.textContent = 'üîê Authorize Google Drive';
                            return;
                        }
                        
                        googleAccessToken = response.access_token;
                        googleSheetsAuthenticated = true;
                        
                        authButton.style.background = '#4caf50';
                        authButton.textContent = '‚úÖ Google Drive Authorized';
                        authButton.disabled = true;
                        authStatusDiv.style.display = 'block';
                        
                        // Enable Step 1
                        const loadButton = document.getElementById('loadDataButton');
                        if (extractSpreadsheetId(document.getElementById('sheetUrl').value)) {
                            loadButton.disabled = false;
                        }
                        
                        addStreamLine('success', '‚úÖ Google Drive authorized successfully!');
                        addStreamLine('info', 'You can now load data from your sheets.');
                        updateButtonStates();
                    },
                });

                // Request access token
                tokenClient.requestAccessToken({ prompt: 'consent' });
                
            } catch (error) {
                console.error('Auth error:', error);
                addStreamLine('error', `Authorization error: ${error.message}`);
                authButton.disabled = false;
                authButton.textContent = 'üîê Authorize Google Drive';
            }
        };

        // Validate Google Sheets URL and enable Step 1 button
        function validateSheetUrl() {
            const sheetUrlInput = document.getElementById('sheetUrl');
            const loadButton = document.getElementById('loadDataButton');
            
            if (!sheetUrlInput || !loadButton) return;

            const url = sheetUrlInput.value.trim();
            const spreadsheetId = extractSpreadsheetId(url);
            
            // Enable Step 1 only if: URL is valid AND Google is authorized
            if (spreadsheetId && url.includes('docs.google.com/spreadsheets') && googleSheetsAuthenticated) {
                loadButton.disabled = false;
                currentSpreadsheetId = spreadsheetId;
            } else {
                loadButton.disabled = true;
                currentSpreadsheetId = null;
            }
        }

        // Update button states based on workflow progress
        function updateButtonStates() {
            const loadButton = document.getElementById('loadDataButton');
            const authButton = document.getElementById('authButton');
            const syncButton = document.getElementById('syncButton');
            const authGoogleButton = document.getElementById('authGoogleButton');
            
            // Google Drive auth button: always enabled (unless already authorized)
            if (authGoogleButton) {
                if (googleSheetsAuthenticated) {
                    authGoogleButton.disabled = true;
                } else {
                    authGoogleButton.disabled = false;
                }
            }
            
            // Step 1: Enabled when valid URL AND Google authorized
            if (loadButton) {
                loadButton.disabled = !(currentSpreadsheetId && googleSheetsAuthenticated);
            }

            // Step 2 (old auth button) - hidden now
            if (authButton) {
                authButton.style.display = 'none';
            }

            // Step 3: Enabled after Step 1 completes (data loaded)
            if (syncButton) {
                // Check both module variable and window property, and ensure programs exist
                const isDataLoaded = sheetDataLoaded || (window.sheetDataLoaded === true);
                const hasPrograms = programDataStore && programDataStore.length > 0;
                syncButton.disabled = !(isDataLoaded && hasPrograms);
            }
        }

        // uploadExcelFile is now defined in global script above (line 607)
        // Removed duplicate to avoid conflicts - global script version is used

        // Process sheet data (works for both Google Sheets and Excel)
        // Expose to window for global script access
        window.processSheetData = async function processSheetData(rows, source = 'google') {
            const tbody = document.getElementById('dataTableBody');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');

            if (!rows || rows.length === 0) {
                throw new Error('No data found in sheet. Sheet may be empty.');
            }

            // Filter out empty rows
            const nonEmptyRows = rows.filter(row => {
                if (!Array.isArray(row)) return false;
                return row.some(cell => cell && cell.toString().trim().length > 0);
            });

            if (nonEmptyRows.length === 0) {
                throw new Error('No data found in sheet. Sheet may be empty.');
            }

            if (nonEmptyRows.length === 1) {
                throw new Error('Only header row found. Please add data rows to your sheet.');
            }

            // Get headers (first row)
            const headers = nonEmptyRows[0].map(h => (h || '').toString().trim().toLowerCase());
            addStreamLine('info', `Headers: ${headers.slice(0, 5).join(', ')}${headers.length > 5 ? '...' : ''}`);

            // Auto-detect columns (for both Google Sheets and Excel)
            const getColumnIndex = (searchTerms) => {
                for (const term of searchTerms) {
                    const idx = headers.findIndex(h => h.includes(term));
                    if (idx >= 0) return idx;
                }
                return -1;
            };

            const universityIdx = getColumnIndex(['universityname', 'university', 'university name']);
            const programIdx = getColumnIndex(['programname', 'program', 'program name']);
            const countryIdx = getColumnIndex(['country']);
            const locationIdx = getColumnIndex(['location', 'campus', 'campus location']);
            const urlIdx = getColumnIndex(['admissionspageurl', 'admissions page url', 'url', 'admission url']);
            const statusIdx = getColumnIndex(['status', 'intake status', 'intakestatus']);
            const deadlineIdx = getColumnIndex(['deadline', 'application deadline', 'applicationdeadline']);
            const intakeOfferedIdx = getColumnIndex(['intake', 'intake offered', 'intakeoffered']);
            const casDeadlineIdx = getColumnIndex(['cas', 'cas deadline', 'casdeadline']);
            const i20DeadlineIdx = getColumnIndex(['i-20', 'i20', 'i-20 deadline', 'i20deadline']);
            const alertsIdx = getColumnIndex(['alert', 'note', 'admission alert', 'admissionalerts', 'notes']);
            
            addStreamLine('info', `Auto-detected columns: University=${universityIdx}, Program=${programIdx}, URL=${urlIdx}`);
            
            addStreamLine('info', `Column indices - University: ${universityIdx}, Program: ${programIdx}, Country: ${countryIdx}, URL: ${urlIdx}`);

            updateProgress(80, 'Formatting data...');

            // Process data rows
            programDataStore = [];
            let html = '';

            // Use non-empty rows for processing
            const dataRows = nonEmptyRows.slice(1); // Skip header
            addStreamLine('info', `Processing ${dataRows.length} data rows...`);
            
            let processedCount = 0;
            for (let i = 0; i < dataRows.length; i++) {
                const row = dataRows[i].map(cell => (cell || '').toString().trim());
                
                // Skip completely empty rows
                if (row.length === 0 || row.every(cell => !cell || cell === '')) {
                    addStreamLine('info', `Skipping empty row ${i + 2}`);
                    continue;
                }
                
                // If first cell is empty but others have data, still process it
                if (!row[0] && row.length > 1 && row.some(cell => cell)) {
                    row[0] = 'N/A'; // Set default for empty first cell
                }
                
                processedCount++;
                if (processedCount % 10 === 0) {
                    updateProgress(80 + (processedCount / dataRows.length) * 10, `Processing row ${processedCount}...`);
                }

                const university = (universityIdx >= 0 && row[universityIdx]) ? row[universityIdx] : 
                                 (row[1] ? row[1] : 'N/A'); // Fallback to column B
                const program = (programIdx >= 0 && row[programIdx]) ? row[programIdx] : 
                              (row[2] ? row[2] : 'N/A'); // Fallback to column C
                const country = (countryIdx >= 0 && row[countryIdx]) ? row[countryIdx] : 
                              (row[3] ? row[3] : 'N/A'); // Fallback to column D
                const campusLocation = (locationIdx >= 0 && row[locationIdx]) ? row[locationIdx] : 
                                     (country || 'NOT_FOUND'); // Use location column, fallback to country
                const url = (urlIdx >= 0 && row[urlIdx]) ? row[urlIdx] : 
                          (row[4] ? row[4] : 'N/A'); // Fallback to column E
                
                // Status and deadline might not exist yet (will be extracted)
                const status = (statusIdx >= 0 && row[statusIdx]) ? row[statusIdx].toLowerCase() : 'pending';
                const deadline = (deadlineIdx >= 0 && row[deadlineIdx]) ? row[deadlineIdx] : 'Not extracted yet';

                // Store for CSV - match exact column structure
                const srNumber = processedCount; // Serial number
                const location = campusLocation || 'NOT_FOUND'; // Use campus location, not country
                programDataStore.push({
                    sr: srNumber,
                    universityName: university,
                    location: location,
                    programName: program,
                    admissionsPageUrl: url,
                    intakesAvailable: (intakeOfferedIdx >= 0 && row[intakeOfferedIdx]) ? row[intakeOfferedIdx] : 'NOT_FOUND',
                    admissionDeadline_found: deadline !== 'Not extracted yet' ? deadline : 'NOT_FOUND',
                    casSubmissionDeadline_found: (casDeadlineIdx >= 0 && row[casDeadlineIdx]) ? row[casDeadlineIdx] : 'NOT_FOUND',
                    errorMessage: '', // Will be filled during sync if error occurs
                    checkedDate: new Date().toISOString().split('T')[0], // Date only (YYYY-MM-DD)
                    remarks: (alertsIdx >= 0 && row[alertsIdx]) ? row[alertsIdx] : '',
                    // Keep old fields for backward compatibility
                    university: university,
                    program: program,
                    country: country,
                    url: url,
                    status: status,
                    deadline: deadline,
                    intakeOffered: (intakeOfferedIdx >= 0 && row[intakeOfferedIdx]) ? row[intakeOfferedIdx] : 'NOT_FOUND',
                    intakeStatus: status,
                    applicationDeadline: deadline,
                    casDeadline: (casDeadlineIdx >= 0 && row[casDeadlineIdx]) ? row[casDeadlineIdx] : 'NOT_FOUND',
                    i20Deadline: (i20DeadlineIdx >= 0 && row[i20DeadlineIdx]) ? row[i20DeadlineIdx] : 'NOT_FOUND',
                    admissionAlerts: (alertsIdx >= 0 && row[alertsIdx]) ? row[alertsIdx] : 'NOT_FOUND',
                    changeType: 'NEW',
                    lastChecked: new Date().toISOString()
                });

                // Determine status badge
                let statusClass = 'pending';
                let statusText = 'PENDING';
                if (status === 'open') {
                    statusClass = 'open';
                    statusText = 'OPEN';
                } else if (status === 'closed') {
                    statusClass = 'closed';
                    statusText = 'CLOSED';
                } else if (status === 'waitlist') {
                    statusClass = 'waitlist';
                    statusText = 'WAITLIST';
                }

                html += '<tr>';
                html += `<td>${srNumber}</td>`;
                html += `<td>${escapeHtml(university)}</td>`;
                html += `<td>${escapeHtml(location)}</td>`;
                html += `<td>${escapeHtml(program)}</td>`;
                html += `<td><a href="${escapeHtml(url)}" target="_blank" style="color: #2196f3; text-decoration: underline;">${escapeHtml(url.length > 50 ? url.substring(0, 50) + '...' : url)}</a></td>`;
                html += `<td>${escapeHtml((intakeOfferedIdx >= 0 && row[intakeOfferedIdx]) ? row[intakeOfferedIdx] : 'NOT_FOUND')}</td>`;
                html += `<td>${escapeHtml(deadline !== 'Not extracted yet' ? deadline : 'NOT_FOUND')}</td>`;
                html += `<td>${escapeHtml((casDeadlineIdx >= 0 && row[casDeadlineIdx]) ? row[casDeadlineIdx] : 'NOT_FOUND')}</td>`;
                html += `<td style="color: ${programDataStore[programDataStore.length - 1].errorMessage ? '#f44336' : '#4caf50'};">${escapeHtml(programDataStore[programDataStore.length - 1].errorMessage || '')}</td>`;
                html += `<td>${new Date().toISOString().split('T')[0]}</td>`;
                html += `<td>${escapeHtml((alertsIdx >= 0 && row[alertsIdx]) ? row[alertsIdx] : '')}</td>`;
                html += '</tr>';
                
                // Log first few rows for debugging
                if (processedCount <= 3) {
                    addStreamLine('info', `Row ${processedCount + 1}: ${university} - ${program.substring(0, 30)}...`);
                }
            }

            if (programDataStore.length === 0) {
                throw new Error('No valid data rows found. Please check your sheet has data beyond the header row.');
            }

            tbody.innerHTML = html;
        }

        // Step 1: Load Data from Sheet - Fetches REAL data from Google Sheets
        window.loadDataFromSheet = async function() {
            const sheetUrl = document.getElementById('sheetUrl').value.trim();
            if (!sheetUrl) {
                alert('Please enter a Google Sheets URL');
                return;
            }

            const spreadsheetId = extractSpreadsheetId(sheetUrl);
            if (!spreadsheetId) {
                alert('Invalid Google Sheets URL. Please check the URL format.');
                return;
            }

            const loadButton = document.getElementById('loadDataButton');
            const authButton = document.getElementById('authButton');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const tbody = document.getElementById('dataTableBody');

            try {
                loadButton.disabled = true;
                progressContainer.style.display = 'block';
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 20px;">Loading data...</td></tr>';

                updateProgress(10, 'Connecting to Google Sheets...');
                addStreamLine('info', `Loading REAL data from sheet: ${spreadsheetId}`);

                // Use CORS proxy to bypass CORS restrictions
                updateProgress(30, 'Fetching data from Google Sheets...');
                addStreamLine('info', `Loading data from sheet: ${spreadsheetId}`);
                
                // Try CSV export via CORS proxy
                const csvUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=0`;
                
                // Use CORS proxy (allorigins.win is a free CORS proxy)
                const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`;
                
                addStreamLine('info', 'Fetching via CORS proxy...');
                let csvText = null;
                let lastError = null;
                
                try {
                    const response = await fetch(proxyUrl, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache'
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    csvText = await response.text();
                    
                    if (!csvText || csvText.trim().length === 0) {
                        throw new Error('Received empty response from sheet');
                    }
                    
                    addStreamLine('success', '‚úÖ Data fetched successfully!');
                    
                } catch (err) {
                    lastError = err.message;
                    addStreamLine('error', `Fetch failed: ${err.message}`);
                    
                    // Fallback: Try direct CSV URL (might work if sheet is public)
                    addStreamLine('info', 'Trying direct CSV URL as fallback...');
                    try {
                        const directResponse = await fetch(csvUrl, {
                            method: 'GET',
                            mode: 'no-cors' // This won't work but worth trying
                        });
                        throw new Error('Direct fetch blocked by CORS. Sheet needs to be publicly accessible or use Step 2 authorization.');
                    } catch (fallbackErr) {
                        throw new Error(`Cannot access sheet. ${lastError}. Sheet may be private. Please make the sheet publicly viewable or use Step 2 to authorize.`);
                    }
                }
                
                if (!csvText) {
                    throw new Error('Failed to fetch sheet data. Please ensure the sheet is publicly accessible or authorize in Step 2.');
                }
                updateProgress(60, 'Processing data...');
                addStreamLine('info', 'Data received, parsing...');

                // Parse CSV - handle line breaks in quoted fields
                const parseCSV = (text) => {
                    const lines = [];
                    let currentLine = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < text.length; i++) {
                        const char = text[i];
                        if (char === '"') {
                            if (inQuotes && text[i + 1] === '"') {
                                // Escaped quote
                                currentLine += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                                currentLine += char;
                            }
                        } else if (char === '\n' && !inQuotes) {
                            if (currentLine.trim()) {
                                lines.push(currentLine);
                            }
                            currentLine = '';
                        } else if (char !== '\r') {
                            currentLine += char;
                        }
                    }
                    if (currentLine.trim()) {
                        lines.push(currentLine);
                    }
                    return lines;
                };

                const lines = parseCSV(csvText);
                addStreamLine('info', `Parsed ${lines.length} lines from CSV`);
                
                if (lines.length === 0) {
                    throw new Error('No data found in sheet. Sheet may be empty.');
                }
                
                // Debug: Show first few lines
                addStreamLine('info', `First line (header): ${lines[0].substring(0, 100)}...`);
                if (lines.length > 1) {
                    addStreamLine('info', `Second line (first data): ${lines[1].substring(0, 100)}...`);
                }
                
                // Filter out empty lines (lines with only commas or whitespace)
                const nonEmptyLines = lines.filter(line => {
                    const trimmed = line.trim();
                    // Check if line has actual content (not just commas, quotes, or whitespace)
                    return trimmed.length > 0 && trimmed.replace(/[,"\s]/g, '').length > 0;
                });
                
                addStreamLine('info', `After filtering empty lines: ${nonEmptyLines.length} lines`);
                
                if (nonEmptyLines.length === 0) {
                    throw new Error('No data found in sheet. Sheet may be empty.');
                }
                
                if (nonEmptyLines.length === 1) {
                    // Check if there are any rows below header that might be filtered
                    addStreamLine('warning', 'Only header row found. Checking if sheet has data rows...');
                    // Show raw CSV preview for debugging
                    const preview = csvText.substring(0, 500);
                    addStreamLine('info', `CSV preview (first 500 chars): ${preview}`);
                    throw new Error('Only header row found. Please add data rows to your sheet below the header row.');
                }

                // Parse CSV line (handle quoted fields with commas)
                const parseCSVLine = (line) => {
                    const result = [];
                    let current = '';
                    let inQuotes = false;
                    
                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        if (char === '"') {
                            if (inQuotes && line[i + 1] === '"') {
                                // Escaped quote
                                current += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if (char === ',' && !inQuotes) {
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    result.push(current.trim());
                    return result;
                };

                const headers = parseCSVLine(lines[0]).map(h => h.replace(/^"|"$/g, '').trim().toLowerCase());
                addStreamLine('info', `Headers: ${headers.slice(0, 5).join(', ')}${headers.length > 5 ? '...' : ''}`);
                
                // Find column indices
                const getColumnIndex = (searchTerms) => {
                    for (const term of searchTerms) {
                        const idx = headers.findIndex(h => h.includes(term));
                        if (idx >= 0) return idx;
                    }
                    return -1;
                };

                // Detect columns - match actual sheet column names
                const universityIdx = getColumnIndex(['universityname', 'university', 'university name']);
                const programIdx = getColumnIndex(['programname', 'program', 'program name']);
                const countryIdx = getColumnIndex(['country']);
                const locationIdx = getColumnIndex(['location', 'campus', 'campus location']);
                const urlIdx = getColumnIndex(['admissionspageurl', 'admissions page url', 'url', 'admission url']);
                const statusIdx = getColumnIndex(['status', 'intake status', 'intakestatus']);
                const deadlineIdx = getColumnIndex(['deadline', 'application deadline', 'applicationdeadline']);
                const intakeOfferedIdx = getColumnIndex(['intake', 'intake offered', 'intakeoffered']);
                const casDeadlineIdx = getColumnIndex(['cas', 'cas deadline', 'casdeadline']);
                const i20DeadlineIdx = getColumnIndex(['i-20', 'i20', 'i-20 deadline', 'i20deadline']);
                const alertsIdx = getColumnIndex(['alert', 'note', 'admission alert', 'admissionalerts', 'notes']);
                
                addStreamLine('info', `Column indices - University: ${universityIdx}, Program: ${programIdx}, Country: ${countryIdx}, URL: ${urlIdx}`);

                updateProgress(80, 'Formatting data...');

                // Process data rows
                programDataStore = [];
                let html = '';

                // Use non-empty lines for processing
                const dataLines = nonEmptyLines.slice(1); // Skip header
                addStreamLine('info', `Processing ${dataLines.length} data rows...`);
                
                let processedCount = 0;
                for (let i = 0; i < dataLines.length; i++) {
                    const row = parseCSVLine(dataLines[i]).map(cell => cell.replace(/^"|"$/g, '').trim());
                    
                    // Skip completely empty rows
                    if (row.length === 0 || row.every(cell => !cell || cell === '')) {
                        addStreamLine('info', `Skipping empty row ${i + 2}`);
                        continue;
                    }
                    
                    // If first cell is empty but others have data, still process it
                    if (!row[0] && row.length > 1 && row.some(cell => cell)) {
                        row[0] = 'N/A'; // Set default for empty first cell
                    }
                    
                    processedCount++;
                    if (processedCount % 10 === 0) {
                        updateProgress(80 + (processedCount / lines.length) * 10, `Processing row ${processedCount}...`);
                    }

                    const university = (universityIdx >= 0 && row[universityIdx]) ? row[universityIdx] : 
                                     (row[1] ? row[1] : 'N/A'); // Fallback to column B
                    const program = (programIdx >= 0 && row[programIdx]) ? row[programIdx] : 
                                  (row[2] ? row[2] : 'N/A'); // Fallback to column C
                    const country = (countryIdx >= 0 && row[countryIdx]) ? row[countryIdx] : 
                                  (row[3] ? row[3] : 'N/A'); // Fallback to column D
                    const campusLocation = (locationIdx >= 0 && row[locationIdx]) ? row[locationIdx] : 
                                         (country || 'NOT_FOUND'); // Use location column, fallback to country
                    const url = (urlIdx >= 0 && row[urlIdx]) ? row[urlIdx] : 
                              (row[4] ? row[4] : 'N/A'); // Fallback to column E
                    
                    // Status and deadline might not exist yet (will be extracted)
                    const status = (statusIdx >= 0 && row[statusIdx]) ? row[statusIdx].toLowerCase() : 'pending';
                    const deadline = (deadlineIdx >= 0 && row[deadlineIdx]) ? row[deadlineIdx] : 'Not extracted yet';

                    // Store for CSV - match exact column structure
                    const srNumber = processedCount; // Serial number
                    const location = campusLocation || 'NOT_FOUND'; // Use campus location, not country
                    programDataStore.push({
                        sr: srNumber,
                        universityName: university,
                        location: location,
                        programName: program,
                        admissionsPageUrl: url,
                        intakesAvailable: (intakeOfferedIdx >= 0 && row[intakeOfferedIdx]) ? row[intakeOfferedIdx] : 'NOT_FOUND',
                        admissionDeadline_found: deadline !== 'Not extracted yet' ? deadline : 'NOT_FOUND',
                        casSubmissionDeadline_found: (casDeadlineIdx >= 0 && row[casDeadlineIdx]) ? row[casDeadlineIdx] : 'NOT_FOUND',
                        errorMessage: '', // Will be filled during sync if error occurs
                        checkedDate: new Date().toISOString().split('T')[0], // Date only (YYYY-MM-DD)
                        remarks: (alertsIdx >= 0 && row[alertsIdx]) ? row[alertsIdx] : '',
                        // Keep old fields for backward compatibility
                        university: university,
                        program: program,
                        country: country,
                        url: url,
                        status: status,
                        deadline: deadline,
                        intakeOffered: (intakeOfferedIdx >= 0 && row[intakeOfferedIdx]) ? row[intakeOfferedIdx] : 'NOT_FOUND',
                        intakeStatus: status,
                        applicationDeadline: deadline,
                        casDeadline: (casDeadlineIdx >= 0 && row[casDeadlineIdx]) ? row[casDeadlineIdx] : 'NOT_FOUND',
                        i20Deadline: (i20DeadlineIdx >= 0 && row[i20DeadlineIdx]) ? row[i20DeadlineIdx] : 'NOT_FOUND',
                        admissionAlerts: (alertsIdx >= 0 && row[alertsIdx]) ? row[alertsIdx] : 'NOT_FOUND',
                        changeType: 'NEW',
                        lastChecked: new Date().toISOString()
                    });

                    const statusClass = status === 'open' ? 'status-open' : 
                                      status === 'closed' ? 'status-closed' : 'status-pending';
                    const statusText = status.toUpperCase();

                    html += '<tr>';
                    html += `<td>${escapeHtml(university)}</td>`;
                    html += `<td>${escapeHtml(program)}</td>`;
                    html += `<td><span class="status-badge ${statusClass}">${statusText}</span></td>`;
                    html += `<td>${escapeHtml(deadline)}</td>`;
                    html += `<td><span class="log-icon">‚úì</span></td>`;
                    html += '</tr>';
                    
                    // Log first few rows for debugging
                    if (processedCount <= 3) {
                        addStreamLine('info', `Row ${processedCount + 1}: ${university} - ${program.substring(0, 30)}...`);
                    }
                }

                if (programDataStore.length === 0) {
                    throw new Error('No valid data rows found. Please check your sheet has data beyond the header row.');
                }

                updateProgress(100, `‚úÖ Loaded ${programDataStore.length} programs`);
                tbody.innerHTML = html;
                sheetDataLoaded = true;
                // Update window property to trigger button state update
                if (window.sheetDataLoaded !== undefined) {
                    window.sheetDataLoaded = true;
                }
                currentSpreadsheetId = spreadsheetId;
                // Step 2 is now hidden (Google Drive auth is Step 0)
                // Enable Step 3 (Sync Now)
                updateButtonStates();

                // Enable Step 2
                authButton.disabled = false;
                addStreamLine('success', `‚úÖ Step 1 Complete: Loaded ${programDataStore.length} programs from REAL Google Sheet`);
                addStreamLine('info', `Processed ${processedCount} rows, ${programDataStore.length} programs extracted`);
                addStreamLine('info', 'Next: Click "Step 2: Authorize Google Sheets"');

                updateButtonStates();

                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Error loading sheet:', error);
                addStreamLine('error', `Failed: ${error.message}`);
                
                if (error.message.includes('private') || error.message.includes('Cannot access')) {
                    tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 20px; color: #ff9800;">‚ö†Ô∏è Sheet requires authentication. Click "Step 2: Authorize Google Sheets" to continue.</td></tr>';
                    // Enable auth button even if load failed (for private sheets)
                    authButton.disabled = false;
                } else {
                    tbody.innerHTML = `<tr><td colspan="5" style="text-align: center; padding: 20px; color: #f44336;">Error: ${error.message}</td></tr>`;
                }
                progressContainer.style.display = 'none';
            } finally {
                loadButton.disabled = false;
                updateButtonStates();
            }
        };

        // Helper functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // AI Token Tracking
        let aiTokenUsage = {
            totalTokens: 0,
            usedTokens: 0,
            agentName: 'Not configured',
            requests: 0
        };
        
        function updateAIProgress(agentName, tokensUsed, totalTokens) {
            const aiProgressBar = document.getElementById('aiProgressBar');
            const aiProgressInfo = document.getElementById('aiProgressInfo');
            
            if (aiTokenUsage.agentName === 'Not configured') {
                aiTokenUsage.agentName = agentName;
                aiTokenUsage.totalTokens = totalTokens || 1000000; // Default estimate
            }
            
            aiTokenUsage.usedTokens += tokensUsed || 0;
            aiTokenUsage.requests += 1;
            
            if (aiProgressBar && aiProgressInfo) {
                const usagePercent = Math.min((aiTokenUsage.usedTokens / aiTokenUsage.totalTokens) * 100, 100);
                aiProgressBar.style.width = usagePercent + '%';
                aiProgressBar.textContent = Math.round(usagePercent) + '%';
                
                aiProgressInfo.innerHTML = `
                    <strong>${aiTokenUsage.agentName}</strong><br>
                    Used: ${aiTokenUsage.usedTokens.toLocaleString()} / ${aiTokenUsage.totalTokens.toLocaleString()} tokens<br>
                    Requests: ${aiTokenUsage.requests}
                `;
            }
        }
        
        // NLP Preview - Natural Language Description
        function addNLPPreview(programName, universityName, extractedData, isNew = false) {
            const nlpPreview = document.getElementById('nlpPreviewContent');
            const nlpCount = document.getElementById('nlpItemCount');
            if (!nlpPreview) return;
            
            // Clear "ready" message if first item
            if (nlpPreview.querySelector('div[style*="text-align: center"]')) {
                nlpPreview.innerHTML = '';
            }
            
            // Create natural language description - SHOW ALL FIELDS
            const descriptions = [];
            
            // Helper function to format field display
            const formatField = (label, value, icon = '') => {
                if (value && value !== 'NOT_FOUND' && value !== '') {
                    return `${icon}${label}: <strong style="color: #4caf50;">${escapeHtml(value)}</strong>`;
                } else {
                    return `${icon}${label}: <strong style="color: #999;">NOT_FOUND</strong>`;
                }
            };
            
            // Show ALL expected fields in order of importance
            
            // 1. Intake Status (always show)
            if (extractedData.intakeStatus && extractedData.intakeStatus !== 'NOT_FOUND') {
                const statusText = extractedData.intakeStatus === 'closed' ? '‚ùå Closed' : 
                                 extractedData.intakeStatus === 'waitlist' ? '‚è≥ Waitlisted' : 
                                 extractedData.intakeStatus === 'open' ? '‚úÖ Open' : extractedData.intakeStatus;
                descriptions.push(`Intake status: <strong>${escapeHtml(statusText)}</strong>`);
            } else {
                descriptions.push(`Intake status: <strong style="color: #999;">NOT_FOUND</strong>`);
            }
            
            // 2. Application Deadline (always show)
            descriptions.push(formatField('Application deadline', extractedData.admissionDeadline || extractedData.applicationDeadline, 'üìÖ '));
            
            // 3. CAS Submission Deadline (always show - important for UK programs)
            descriptions.push(formatField('CAS submission deadline', extractedData.casDeadline || extractedData.casSubmissionDeadline_found, 'üá¨üáß '));
            
            // 4. I-20 Deadline (always show - important for USA programs)
            descriptions.push(formatField('I-20 deadline', extractedData.i20Deadline || extractedData.i20Deadline_found, 'üá∫üá∏ '));
            
            // 5. Intakes Available (always show)
            descriptions.push(formatField('Intake periods', extractedData.intakesAvailable || extractedData.intakeOffered, 'üìÜ '));
            
            // 6. Campus Location (always show)
            descriptions.push(formatField('Campus location', extractedData.campusLocation || extractedData.location, 'üìç '));
            
            // 7. Extracted University Name (if different from provided)
            if (extractedData.extractedUniversityName && extractedData.extractedUniversityName !== 'NOT_FOUND') {
                descriptions.push(formatField('Extracted university name', extractedData.extractedUniversityName, 'üèõÔ∏è '));
            }
            
            // 8. Extracted Program Name (if different from provided)
            if (extractedData.extractedProgramName && extractedData.extractedProgramName !== 'NOT_FOUND') {
                descriptions.push(formatField('Extracted program name', extractedData.extractedProgramName, 'üìö '));
            }
            
            // 9. Extracted Campus Location (if different from provided)
            if (extractedData.extractedCampusLocation && extractedData.extractedCampusLocation !== 'NOT_FOUND') {
                descriptions.push(formatField('Extracted campus location', extractedData.extractedCampusLocation, 'üó∫Ô∏è '));
            }
            
            // 10. Remarks/Additional Notes (only if meaningful)
            if (extractedData.remarks && extractedData.remarks !== 'NOT_FOUND' && extractedData.remarks !== 'Data extracted via pattern matching' && !extractedData.remarks.includes('Extracted via') && extractedData.remarks.trim().length > 0) {
                descriptions.push(`üìù Additional notes: <strong>${escapeHtml(extractedData.remarks)}</strong>`);
            }
            
            // 11. Error Message (if any)
            if (extractedData.errorMessage && extractedData.errorMessage.trim().length > 0) {
                descriptions.push(`‚ö†Ô∏è Error: <strong style="color: #f44336;">${escapeHtml(extractedData.errorMessage)}</strong>`);
            }
            
            const nlpDiv = document.createElement('div');
            nlpDiv.className = `nlp-item ${isNew ? 'new' : ''}`;
            nlpDiv.innerHTML = `
                <div class="nlp-item-header">üìö ${escapeHtml(universityName || 'Unknown University')}</div>
                <div style="font-size: 11px; color: #666; margin-bottom: 6px;">Program: ${escapeHtml(programName || 'Unknown Program')}</div>
                <div class="nlp-item-content">
                    ${descriptions.join('<br>')}
                </div>
            `;
            
            nlpPreview.insertBefore(nlpDiv, nlpPreview.firstChild);
            
            // Keep only last 20 items
            const items = nlpPreview.querySelectorAll('.nlp-item');
            if (items.length > 20) {
                items[items.length - 1].remove();
            }
            
            // Update count
            const currentCount = parseInt(nlpCount.textContent) || 0;
            nlpCount.textContent = currentCount + 1;
        }
        
        function addErrorToPreview(programName, universityName, errorMessage) {
            const errorPreviewContent = document.getElementById('errorPreviewContent');
            const errorCount = document.getElementById('errorCount');
            
            if (!errorPreviewContent) return;
            
            // Remove "No errors" message if present
            if (errorPreviewContent.textContent.includes('No errors yet')) {
                errorPreviewContent.innerHTML = '';
            }
            
            const errorItem = document.createElement('div');
            errorItem.className = 'error-item';
            errorItem.innerHTML = `
                <div class="error-item-header">${universityName || 'Unknown'} - ${(programName || 'Unknown').substring(0, 30)}...</div>
                <div class="error-item-message">${errorMessage || 'Unknown error'}</div>
            `;
            
            errorPreviewContent.insertBefore(errorItem, errorPreviewContent.firstChild);
            
            // Limit to 10 most recent errors
            const errors = errorPreviewContent.querySelectorAll('.error-item');
            if (errors.length > 10) {
                errors[errors.length - 1].remove();
            }
            
            // Update error count
            if (errorCount) {
                errorCount.textContent = errors.length;
            }
        }
        
        function updateProgress(percent, text) {
            // Also expose to window for global script access
            if (!window.updateProgress) {
                window.updateProgress = updateProgress;
            }
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            if (progressBar) {
                progressBar.style.width = percent + '%';
                progressBar.textContent = Math.round(percent) + '%';
            }
            if (progressText) {
                progressText.textContent = text;
            }
        }

        // Step 2: Authorize Google Sheets (simplified - marks as authorized)
        window.handleAuthClick = async function() {
            if (!sheetDataLoaded && !currentSpreadsheetId) {
                alert('Please complete Step 1 first: Load Data from Sheet');
                return;
            }

            const authButton = document.getElementById('authButton');
            const syncButton = document.getElementById('syncButton');
            const progressContainer = document.getElementById('progressContainer');

            try {
                authButton.disabled = true;
                progressContainer.style.display = 'block';

                updateProgress(20, 'Authorizing Google Sheets access...');
                addStreamLine('info', 'Starting Google Sheets authorization...');

                await new Promise(resolve => setTimeout(resolve, 1000));
                updateProgress(60, 'Setting up permissions...');
                
                await new Promise(resolve => setTimeout(resolve, 800));
                updateProgress(100, '‚úÖ Authorized!');

                // Mark as authenticated
                googleSheetsAuthenticated = true;
                authButton.disabled = true;
                authButton.textContent = '‚úÖ Step 2: Authorized';
                authButton.style.background = '#4caf50';

                // Enable Step 3
                syncButton.disabled = false;
                addStreamLine('success', '‚úÖ Step 2 Complete: Google Sheets authorized');
                addStreamLine('info', 'Next: Click "Step 3: Sync Now"');

                updateButtonStates();

                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Auth error:', error);
                addStreamLine('error', `Authorization failed: ${error.message}`);
                authButton.disabled = false;
                progressContainer.style.display = 'none';
            }
        };

        // Check for pending scheduled sync
        function checkPendingSync() {
            const pendingSync = localStorage.getItem('pendingSync');
            if (pendingSync) {
                try {
                    const syncData = JSON.parse(pendingSync);
                    const sheetUrlInput = document.getElementById('sheetUrl');
                    if (sheetUrlInput && syncData.sheetUrl) {
                        sheetUrlInput.value = syncData.sheetUrl;
                        localStorage.removeItem('pendingSync');
                        // Auto-trigger sync after a short delay
                        setTimeout(() => {
                            if (confirm('Scheduled sync detected. Would you like to run it now?')) {
                                loadDataFromSheet().then(() => {
                                    setTimeout(() => {
                                        runManualSync();
                                    }, 2000);
                                });
                            }
                        }, 1000);
                    }
                } catch (e) {
                    console.error('Error processing pending sync:', e);
                }
            }
        }
        
        // Add event listener to URL input
        document.addEventListener('DOMContentLoaded', () => {
            checkPendingSync();
            
            const sheetUrlInput = document.getElementById('sheetUrl');
            if (sheetUrlInput) {
                sheetUrlInput.addEventListener('input', () => {
                    validateSheetUrl();
                    updateButtonStates();
                });
                sheetUrlInput.addEventListener('paste', () => {
                    setTimeout(() => {
                        validateSheetUrl();
                        updateButtonStates();
                    }, 100);
                });
                validateSheetUrl();
                updateButtonStates();
            }
        });

        function addSampleData() {
            const tbody = document.getElementById('dataTableBody');
            const sampleData = [
                { university: 'University of Oxford', program: 'MSc in Computer Science', status: 'open', deadline: '2024-12-15', intakeOffered: 'Fall, Spring', casDeadline: '2024-11-15', i20Deadline: 'NOT_FOUND', admissionAlerts: 'Early application recommended', changeType: 'CHANGED', lastChecked: new Date().toISOString() },
                { university: 'Stanford', program: 'MS AI', status: 'open', deadline: '2024-12-20', intakeOffered: 'Fall', casDeadline: 'NOT_FOUND', i20Deadline: '2024-11-20', admissionAlerts: 'GRE required', changeType: 'NEW', lastChecked: new Date().toISOString() },
                { university: 'U of T', program: 'MEng', status: 'closed', deadline: '-', intakeOffered: 'Fall', casDeadline: 'NOT_FOUND', i20Deadline: 'NOT_FOUND', admissionAlerts: 'Program closed for 2024', changeType: 'LOST', lastChecked: new Date().toISOString() },
                { university: 'MIT', program: 'Computer Science', status: 'open', deadline: '2024-12-10', intakeOffered: 'Fall, Spring', casDeadline: 'NOT_FOUND', i20Deadline: '2024-11-10', admissionAlerts: 'Highly competitive', changeType: 'CHANGED', lastChecked: new Date().toISOString() },
                { university: 'Harvard', program: 'MBA', status: 'waitlist', deadline: '2024-11-30', intakeOffered: 'Fall', casDeadline: 'NOT_FOUND', i20Deadline: '2024-10-30', admissionAlerts: 'Waitlist notification sent', changeType: 'NEW', lastChecked: new Date().toISOString() }
            ];
            programDataStore = sampleData;
            let html = '';
            sampleData.forEach(item => {
                const statusClass = item.status === 'open' ? 'status-open' : item.status === 'closed' ? 'status-closed' : 'status-pending';
                html += '<tr>';
                html += `<td>${item.university}</td>`;
                html += `<td>${item.program}</td>`;
                html += `<td><span class="status-badge ${statusClass}">${item.status.toUpperCase()}</span></td>`;
                html += `<td>${item.deadline}</td>`;
                html += `<td><span class="log-icon">‚úì</span></td>`;
                html += '</tr>';
            });
            tbody.innerHTML = html;
        }
        // Step 3: Sync Now (process and update data)
        window.runManualSync = async function() {
            // Check both module variable and window property
            const isDataLoaded = sheetDataLoaded || (window.sheetDataLoaded === true);
            const hasPrograms = (programDataStore && programDataStore.length > 0) || (window.programDataStore && window.programDataStore.length > 0);
            
            if (!isDataLoaded || !hasPrograms) {
                alert('Please complete Step 1 first: Load Data from Sheet or Upload Excel File');
                return;
            }

            const button = document.getElementById('syncButton');
            const stream = document.getElementById('executionStream');
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            const tbody = document.getElementById('dataTableBody');

            button.disabled = true;
            button.textContent = '‚è≥ Syncing...';
            stream.innerHTML = '';
            progressContainer.style.display = 'block';
            
            // Reset statistics
            resetStats();

            addStreamLine('info', 'Starting sync process...');
            addStreamLine('info', `Processing ${programDataStore.length} programs...`);
            
            // Update initial program count
            syncStats.programsFound = programDataStore.length;
            updateStat('statProgramsFound', programDataStore.length);

            try {
                updateProgress(10, 'Initializing extraction...');
                addStreamLine('info', 'Preparing to extract data from program URLs...');
                
                await new Promise(resolve => setTimeout(resolve, 500));
                
                updateProgress(20, 'Extracting program data...');
                addStreamLine('info', `Found ${programDataStore.length} programs to process`);

                // Process each program
                let processedCount = 0;
                let successCount = 0;
                let errorCount = 0;

                for (let i = 0; i < programDataStore.length; i++) {
                    const program = programDataStore[i];
                    processedCount++;
                    
                    const progressPercent = 20 + (processedCount / programDataStore.length) * 70;
                    updateProgress(progressPercent, `Processing ${processedCount}/${programDataStore.length}...`);
                    
                    addStreamLine('info', `[${processedCount}/${programDataStore.length}] Processing: ${program.universityName || program.university} - ${(program.programName || program.program || '').substring(0, 40)}...`);

                    try {
                        // Extract data from URL - REAL FETCHING
                        const url = program.admissionsPageUrl || program.url;
                        
                        // Extract names from URL and compare with provided names
                        let extractedNames = { extractedUniversityName: '', extractedProgramName: '', extractedCampusLocation: '' };
                        if (url && url !== 'N/A' && url !== 'NOT_FOUND' && url.startsWith('http')) {
                            extractedNames = extractNamesFromUrl(url);
                            
                            // Compare provided names with extracted names
                            const providedUniName = program.universityName || program.university || '';
                            const providedProgName = program.programName || program.program || '';
                            const providedCampusName = program.location || program.campusLocation || '';
                            
                            // Check for mismatches
                            const uniMatch = compareNames(providedUniName, extractedNames.extractedUniversityName);
                            const progMatch = compareNames(providedProgName, extractedNames.extractedProgramName);
                            const campusMatch = compareNames(providedCampusName, extractedNames.extractedCampusLocation);
                            
                            // Add appended columns if there's a mismatch
                            if (!uniMatch && extractedNames.extractedUniversityName) {
                                program.appendedUniName = extractedNames.extractedUniversityName;
                            }
                            if (!progMatch && extractedNames.extractedProgramName) {
                                program.appendedProgramName = extractedNames.extractedProgramName;
                            }
                            if (!campusMatch && extractedNames.extractedCampusLocation) {
                                program.appendedCampusName = extractedNames.extractedCampusLocation;
                            }
                            
                            // Also extract from HTML content later (more accurate)
                        }
                        
                        // Track URL scanned
                        if (url && url !== 'N/A' && url !== 'NOT_FOUND' && url.startsWith('http')) {
                            syncStats.urlsScanned++;
                            updateStat('statUrlsScanned', syncStats.urlsScanned);
                        }
                        
                        if (url && url !== 'N/A' && url !== 'NOT_FOUND' && url.startsWith('http')) {
                            try {
                                addStreamLine('info', `[${processedCount}] Processing: ${url.substring(0, 60)}...`);
                                
                                // Human-like delay: 15-20 seconds per page for thorough extraction (like a human reading carefully)
                                if (processedCount > 1) {
                                    const readTime = 15000 + Math.random() * 5000; // 15-20 seconds random
                                    addStreamLine('info', `[${processedCount}] ‚è≥ Waiting ${Math.round(readTime/1000)} seconds (thorough human-like reading time for best data extraction)...`);
                                    await new Promise(resolve => setTimeout(resolve, readTime));
                                }
                                
                                // USE PROPER BACKEND API - Server-side fetching + AI extraction
                                // This is the LEGAL and RELIABLE solution - no CORS issues!
                                const config = getAIConfig();
                                const hasAIKey = (config.aiProvider === 'gemini' && config.geminiApiKey) || (config.aiProvider === 'openai' && config.openaiApiKey);
                                
                                if (hasAIKey) {
                                    const agentName = config.aiProvider === 'gemini' ? 'Gemini 1.5 Flash' : 'OpenAI GPT-4';
                                    // Use backend API for proper extraction (server-side, no CORS)
                                    addStreamLine('info', `[${processedCount}] ü§ñ Using backend API with AI extraction (${agentName})...`);
                                    updateAIProgress(agentName, 0, 0); // Initialize AI progress
                                    
                                    let apiSuccess = false;
                                    try {
                                        const apiResponse = await fetch('/api/extract', {
                                            method: 'POST',
                                            headers: {
                                                'Content-Type': 'application/json',
                                            },
                                            body: JSON.stringify({
                                                url: url,
                                                programName: program.programName || program.program,
                                                universityName: program.universityName || program.university,
                                                aiProvider: config.aiProvider,
                                                apiKey: config.aiProvider === 'gemini' ? config.geminiApiKey : config.openaiApiKey,
                                                geminiApiKey: config.geminiApiKey // Always send Gemini key for fallback
                                            })
                                        });
                                        
                                        if (!apiResponse.ok) {
                                            const errorData = await apiResponse.json().catch(() => ({ error: `HTTP ${apiResponse.status}` }));
                                            throw new Error(errorData.error || `API returned HTTP ${apiResponse.status}`);
                                        }
                                        
                                        const extracted = await apiResponse.json();
                                        
                                        // Check if fallback was used
                                        if (extracted.fallbackUsed) {
                                            addStreamLine('warning', `[${processedCount}] ‚ö†Ô∏è OpenAI rate limit hit. Automatically switched to Gemini fallback.`);
                                            updateAIProgress('Gemini 1.5 Flash (Fallback)', 1000, 0);
                                        } else {
                                            // Estimate tokens used (rough estimate: ~1000 tokens per request)
                                            const estimatedTokens = 1000;
                                            updateAIProgress(agentName, estimatedTokens, 0);
                                        }
                                        
                                        // Handle multiple programs/campuses - create separate rows
                                        const programsToAdd = [];
                                        
                                        // Check for multiple programs
                                        if (extracted.multiplePrograms && extracted.multiplePrograms.length > 0) {
                                            extracted.multiplePrograms.forEach((multiProg, idx) => {
                                                const newProgram = {
                                                    ...program,
                                                    programName: multiProg.programName || program.programName || program.program,
                                                    location: multiProg.campusLocation || extracted.campusLocation || program.location || 'NOT_FOUND',
                                                    admissionDeadline_found: multiProg.admissionDeadline || 'NOT_FOUND',
                                                    casSubmissionDeadline_found: multiProg.casDeadline || 'NOT_FOUND',
                                                    i20Deadline_found: multiProg.i20Deadline || 'NOT_FOUND',
                                                    intakesAvailable: multiProg.intakesAvailable || 'NOT_FOUND',
                                                    intakeStatus: multiProg.intakeStatus || 'NOT_FOUND',
                                                    errorMessage: '',
                                                    checkedDate: new Date().toISOString().split('T')[0],
                                                    remarks: extracted.remarks || 'Extracted via backend API + AI',
                                                    changeType: 'NEW',
                                                    isNewlyFetched: true,
                                                    lastChecked: new Date().toISOString()
                                                };
                                                programsToAdd.push(newProgram);
                                            });
                                        }
                                        // Check for multiple campuses
                                        else if (extracted.multipleCampuses && extracted.multipleCampuses.length > 0) {
                                            extracted.multipleCampuses.forEach((multiCampus, idx) => {
                                                const newProgram = {
                                                    ...program,
                                                    location: multiCampus.campusLocation || 'NOT_FOUND',
                                                    admissionDeadline_found: multiCampus.admissionDeadline || 'NOT_FOUND',
                                                    casSubmissionDeadline_found: multiCampus.casDeadline || 'NOT_FOUND',
                                                    i20Deadline_found: multiCampus.i20Deadline || 'NOT_FOUND',
                                                    intakesAvailable: multiCampus.intakesAvailable || 'NOT_FOUND',
                                                    intakeStatus: multiCampus.intakeStatus || 'NOT_FOUND',
                                                    errorMessage: '',
                                                    checkedDate: new Date().toISOString().split('T')[0],
                                                    remarks: extracted.remarks || 'Extracted via backend API + AI',
                                                    changeType: 'NEW',
                                                    isNewlyFetched: true,
                                                    lastChecked: new Date().toISOString()
                                                };
                                                programsToAdd.push(newProgram);
                                            });
                                        }
                                        // Single program/campus
                                        else {
                                            program.admissionDeadline = extracted.admissionDeadline || 'NOT_FOUND';
                                            program.admissionDeadline_found = extracted.admissionDeadline || 'NOT_FOUND';
                                            program.casSubmissionDeadline_found = extracted.casDeadline || 'NOT_FOUND';
                                            program.i20Deadline_found = extracted.i20Deadline || 'NOT_FOUND';
                                            program.intakesAvailable = extracted.intakesAvailable || 'NOT_FOUND';
                                            program.intakeStatus = extracted.intakeStatus || 'NOT_FOUND';
                                            program.location = extracted.campusLocation || program.location || 'NOT_FOUND';
                                            program.errorMessage = extracted.errorMessage || '';
                                            program.checkedDate = new Date().toISOString().split('T')[0];
                                            program.syncDate = new Date().toISOString(); // Store sync date
                                            program.remarks = extracted.remarks || 'Extracted via backend API + AI';
                                            program.intakeOffered = extracted.intakesAvailable || 'NOT_FOUND';
                                            program.applicationDeadline = extracted.admissionDeadline || 'NOT_FOUND';
                                            program.casDeadline = extracted.casDeadline || 'NOT_FOUND';
                                            program.changeType = 'NEW';
                                            program.isNewlyFetched = true;
                                            program.lastChecked = new Date().toISOString();
                                            
                                            // Update appended names from extracted data if available
                                            const providedUniName = program.universityName || program.university || '';
                                            const providedProgName = program.programName || program.program || '';
                                            const providedCampus = program.location || program.campusLocation || '';
                                            
                                            // Use extracted names from API if available
                                            const extractedUni = extracted.extractedUniversityName || '';
                                            const extractedProg = extracted.extractedProgramName || '';
                                            const extractedCampus = extracted.extractedCampusLocation || extracted.campusLocation || '';
                                            
                                            if (extractedUni && extractedUni !== 'NOT_FOUND' && !compareNames(providedUniName, extractedUni)) {
                                                program.appendedUniName = extractedUni;
                                            }
                                            if (extractedProg && extractedProg !== 'NOT_FOUND' && !compareNames(providedProgName, extractedProg)) {
                                                program.appendedProgramName = extractedProg;
                                            }
                                            if (extractedCampus && extractedCampus !== 'NOT_FOUND' && !compareNames(providedCampus, extractedCampus)) {
                                                program.appendedCampusName = extractedCampus;
                                            }
                                            
                                            // Add NLP preview
                                            addNLPPreview(
                                                program.programName || program.program,
                                                program.universityName || program.university,
                                                extracted,
                                                true
                                            );
                                            
                                            successCount++;
                                            addStreamLine('success', `‚úÖ [${processedCount}] Backend API extracted: ${program.universityName || program.university} - Deadline: ${program.admissionDeadline_found}, Intakes: ${program.intakesAvailable}`);
                                        }
                                        
                                        // Add multiple programs/campuses to data store
                                        if (programsToAdd.length > 0) {
                                            programsToAdd.forEach((newProg, idx) => {
                                                programDataStore.push(newProg);
                                                addNLPPreview(
                                                    newProg.programName || newProg.program,
                                                    newProg.universityName || newProg.university,
                                                    {
                                                        campusLocation: newProg.location,
                                                        admissionDeadline: newProg.admissionDeadline_found,
                                                        casDeadline: newProg.casSubmissionDeadline_found,
                                                        i20Deadline: newProg.i20Deadline_found,
                                                        intakesAvailable: newProg.intakesAvailable,
                                                        intakeStatus: newProg.intakeStatus,
                                                        remarks: newProg.remarks
                                                    },
                                                    true
                                                );
                                                successCount++;
                                                addStreamLine('success', `‚úÖ [${processedCount}] Added ${programsToAdd.length > 1 ? 'program/campus' : 'program'}: ${newProg.universityName || newProg.university} - ${newProg.programName || newProg.program} (${newProg.location})`);
                                            });
                                            // Remove original program if we created multiple rows
                                            const originalIndex = programDataStore.findIndex(p => p === program);
                                            if (originalIndex >= 0) {
                                                programDataStore.splice(originalIndex, 1);
                                            }
                                        }
                                        
                                        apiSuccess = true;
                                        continue; // Skip to next program
                                    } catch (apiError) {
                                        addStreamLine('error', `[${processedCount}] Backend API failed: ${apiError.message}. Falling back to pattern matching...`);
                                        // Fall through to pattern matching below
                                    }
                                    
                                    // If API succeeded, we already continued, so this won't execute
                                    if (apiSuccess) {
                                        continue; // Extra safety check
                                    }
                                } else {
                                    addStreamLine('warning', `[${processedCount}] AI Agent not configured. Configure in "Use AI Agent" menu for reliable extraction.`);
                                    addStreamLine('info', `[${processedCount}] Falling back to pattern matching (less accurate)...`);
                                }
                                
                                // Fallback: Try to fetch HTML for pattern matching (if AI not configured or API failed)
                                let htmlContent = null;
                                try {
                                    addStreamLine('info', `[${processedCount}] Attempting to fetch HTML for pattern matching...`);
                                    const proxyFunctionUrl = `/api/proxy?url=${encodeURIComponent(url)}`;
                                    const proxyResponse = await fetch(proxyFunctionUrl, {
                                        method: 'GET',
                                        mode: 'cors',
                                        cache: 'no-cache'
                                    });
                                    
                                    if (proxyResponse.ok) {
                                        htmlContent = await proxyResponse.text();
                                        if (htmlContent && htmlContent.length > 100) {
                                            addStreamLine('success', `[${processedCount}] ‚úÖ HTML fetched: ${(htmlContent.length / 1024).toFixed(1)}KB`);
                                        } else {
                                            htmlContent = null;
                                        }
                                    }
                                } catch (fetchError) {
                                    addStreamLine('warning', `[${processedCount}] HTML fetch failed: ${fetchError.message}`);
                                }
                                
                                // Extract data from HTML content (pattern matching)
                                let extracted;
                                if (htmlContent) {
                                    addStreamLine('info', `[${processedCount}] üîç Extracting data from HTML (checking hidden content, tabs, dropdowns)...`);
                                    extracted = extractDataFromContent(
                                        htmlContent,
                                        program.programName || program.program,
                                        program.universityName || program.university,
                                        url
                                    );
                                    
                                    // If pattern matching found little, try AI as enhancement
                                    if (hasAIKey && (extracted.admissionDeadline === 'NOT_FOUND' || extracted.intakesAvailable === 'NOT_FOUND')) {
                                        addStreamLine('info', `[${processedCount}] Pattern matching incomplete, enhancing with AI Agent...`);
                                        try {
                                            const aiEnhanced = await extractWithAI(htmlContent, program.programName || program.program, program.universityName || program.university, url);
                                            
                                            // Use AI results if they're better
                                            if (aiEnhanced.admissionDeadline !== 'NOT_FOUND') extracted.admissionDeadline = aiEnhanced.admissionDeadline;
                                            if (aiEnhanced.casDeadline !== 'NOT_FOUND') extracted.casDeadline = aiEnhanced.casDeadline;
                                            if (aiEnhanced.intakesAvailable !== 'NOT_FOUND') extracted.intakesAvailable = aiEnhanced.intakesAvailable;
                                            if (aiEnhanced.remarks && aiEnhanced.remarks !== 'NOT_FOUND') extracted.remarks = aiEnhanced.remarks;
                                            
                                            addStreamLine('success', `[${processedCount}] ‚úÖ AI enhancement completed`);
                                        } catch (aiError) {
                                            addStreamLine('warning', `[${processedCount}] AI enhancement failed, using pattern matching results`);
                                        }
                                    }
                                } else {
                                    // No HTML available - try AI directly if configured
                                    if (hasAIKey) {
                                        addStreamLine('info', `[${processedCount}] HTML fetch failed, using AI Agent directly...`);
                                        try {
                                            extracted = await extractWithAI(null, program.programName || program.program, program.universityName || program.university, url);
                                            extracted.remarks = 'Extracted via AI Agent (HTML fetch failed)';
                                        } catch (aiError) {
                                            extracted = {
                                                admissionDeadline: 'NOT_FOUND',
                                                casDeadline: 'NOT_FOUND',
                                                intakesAvailable: 'NOT_FOUND',
                                                intakeStatus: 'NOT_FOUND',
                                                errorMessage: `HTML fetch failed and AI extraction failed: ${aiError.message}`,
                                                remarks: 'Both HTML fetch and AI extraction failed'
                                            };
                                        }
                                    } else {
                                        // No HTML and no AI - return NOT_FOUND
                                        extracted = {
                                            admissionDeadline: 'NOT_FOUND',
                                            casDeadline: 'NOT_FOUND',
                                            intakesAvailable: 'NOT_FOUND',
                                            intakeStatus: 'NOT_FOUND',
                                            errorMessage: 'Unable to fetch HTML. Configure AI Agent for reliable extraction.',
                                            remarks: 'HTML fetch failed. Configure AI Agent for better results.'
                                        };
                                    }
                                }
                                
                                // Update program with extracted data
                                program.admissionDeadline = extracted.admissionDeadline || 'NOT_FOUND';
                                program.admissionDeadline_found = extracted.admissionDeadline || 'NOT_FOUND';
                                program.casSubmissionDeadline_found = extracted.casDeadline || 'NOT_FOUND';
                                program.i20Deadline_found = extracted.i20Deadline || 'NOT_FOUND';
                                program.intakesAvailable = extracted.intakesAvailable || 'NOT_FOUND';
                                program.intakeStatus = extracted.intakeStatus || 'NOT_FOUND';
                                program.errorMessage = extracted.errorMessage || '';
                                program.checkedDate = new Date().toISOString().split('T')[0];
                                program.syncDate = new Date().toISOString(); // Store sync date
                                
                                // Update appended names from extracted data if available
                                const providedUniName = program.universityName || program.university || '';
                                const providedProgName = program.programName || program.program || '';
                                const providedCampus = program.location || program.campusLocation || '';
                                
                                // Use extracted names from API if available (for pattern matching, these may not be available)
                                const extractedCampus = extracted.campusLocation || '';
                                
                                if (extractedCampus && extractedCampus !== 'NOT_FOUND' && !compareNames(providedCampus, extractedCampus)) {
                                    program.appendedCampusName = extractedCampus;
                                }
                                program.remarks = extracted.remarks || 'Data extracted via pattern matching';
                                
                                // Keep old fields for compatibility
                                program.intakeOffered = extracted.intakesAvailable || 'NOT_FOUND';
                                program.applicationDeadline = extracted.admissionDeadline || 'NOT_FOUND';
                                program.casDeadline = extracted.casDeadline || 'NOT_FOUND';
                                program.changeType = 'NEW'; // Mark as new/fetched data
                                program.isNewlyFetched = true; // Flag for highlighting
                                program.lastChecked = new Date().toISOString();
                                
                                // Add NLP preview with all extracted fields
                                addNLPPreview(
                                    program.programName || program.program,
                                    program.universityName || program.university,
                                    {
                                        campusLocation: program.location || extracted.campusLocation || 'NOT_FOUND',
                                        admissionDeadline: extracted.admissionDeadline || 'NOT_FOUND',
                                        admissionDeadline_found: extracted.admissionDeadline || 'NOT_FOUND',
                                        applicationDeadline: extracted.admissionDeadline || 'NOT_FOUND',
                                        casDeadline: extracted.casDeadline || 'NOT_FOUND',
                                        i20Deadline: extracted.i20Deadline || 'NOT_FOUND',
                                        intakesAvailable: extracted.intakesAvailable || 'NOT_FOUND',
                                        intakeStatus: extracted.intakeStatus || 'NOT_FOUND',
                                        remarks: extracted.remarks || 'Data extracted via pattern matching'
                                    },
                                    true // isNew
                                );
                                
                                successCount++;
                                addStreamLine('success', `‚úÖ [${processedCount}] Extracted: ${program.universityName || program.university} - Deadline: ${program.admissionDeadline_found}`);
                                
                            } catch (error) {
                                program.errorMessage = `Failed to extract: ${error.message}`;
                                program.admissionDeadline = 'NOT_FOUND';
                                program.admissionDeadline_found = 'NOT_FOUND';
                                program.casSubmissionDeadline_found = 'NOT_FOUND';
                                program.checkedDate = new Date().toISOString().split('T')[0];
                                program.remarks = `Error: ${error.message}`;
                                errorCount++;
                                addStreamLine('error', `‚ùå [${processedCount}] Extraction failed: ${program.universityName || program.university} - ${error.message}`);
                            }
                        } else {
                            program.admissionDeadline = 'NOT_FOUND';
                            program.admissionDeadline_found = 'NOT_FOUND';
                            program.casSubmissionDeadline_found = 'NOT_FOUND';
                            program.errorMessage = 'No valid URL provided';
                            program.checkedDate = new Date().toISOString().split('T')[0];
                            program.remarks = 'URL missing or invalid';
                            program.intakeStatus = 'pending';
                            program.applicationDeadline = 'NOT_FOUND';
                            program.changeType = 'NEW';
                            errorCount++;
                            addStreamLine('warning', `‚ö†Ô∏è [${processedCount}] No valid URL: ${program.universityName || program.university}`);
                        }
                    } catch (error) {
                        errorCount++;
                        syncStats.errorMessages++;
                        updateStat('statErrorMessages', syncStats.errorMessages);
                        
                        // Check if blocked
                        if (error.message.includes('403') || error.message.includes('429') || 
                            error.message.includes('blocked') || error.message.includes('CORS') ||
                            error.message.includes('Forbidden')) {
                            syncStats.urlsBlocked++;
                            updateStat('statUrlsBlocked', syncStats.urlsBlocked);
                        }
                        
                        program.intakeStatus = 'pending';
                        program.admissionDeadline = 'ERROR';
                        program.admissionDeadline_found = 'ERROR';
                        program.applicationDeadline = 'ERROR';
                        program.changeType = 'NEW';
                        addStreamLine('error', `‚ùå [${processedCount}] Failed: ${program.university} - ${error.message}`);
                    }

                    // Additional delay every 5 requests for safety
                    if (processedCount % 5 === 0) {
                        addStreamLine('info', `[${processedCount}] Pausing for 3 seconds to avoid rate limiting...`);
                        await new Promise(resolve => setTimeout(resolve, 3000));
                    }
                }

                updateProgress(90, 'Updating display...');
                addStreamLine('info', `Processed: ${processedCount} | Success: ${successCount} | Errors: ${errorCount}`);

                // Update table with extracted data
                let html = '';
                let rowIndex = 0;
                for (const program of programDataStore) {
                    rowIndex++;
                    const status = program.intakeStatus || 'pending';
                    const deadline = program.applicationDeadline || 'Not extracted yet';
                    
                    let statusClass = 'pending';
                    let statusText = 'PENDING';
                    if (status === 'open') {
                        statusClass = 'open';
                        statusText = 'OPEN';
                    } else if (status === 'closed') {
                        statusClass = 'closed';
                        statusText = 'CLOSED';
                    } else if (status === 'waitlist') {
                        statusClass = 'waitlist';
                        statusText = 'WAITLIST';
                    }

                    // Color code based on change type and newly fetched data
                    let rowClass = '';
                    if (program.isNewlyFetched) {
                        // Highlight newly scraped/fetched data with bright green
                        rowClass = 'style="background-color: #c8e6c9; border-left: 4px solid #4caf50;"'; // Bright green with left border
                    } else if (program.changeType === 'CHANGED') {
                        rowClass = 'style="background-color: #e3f2fd;"'; // Light blue
                    } else if (program.changeType === 'NEW') {
                        rowClass = 'style="background-color: #e8f5e9;"'; // Light green
                    } else if (program.changeType === 'LOST') {
                        rowClass = 'style="background-color: #ffebee;"'; // Light red
                    }

                    const srNum = program.sr || rowIndex;
                    const uniName = program.universityName || program.university || 'N/A';
                    const campusLoc = program.location || program.campusLocation || 'NOT_FOUND'; // Campus location from URL
                    const progName = program.programName || program.program || 'N/A';
                    const admUrl = program.admissionsPageUrl || program.url || '';
                    const intakesAvail = program.intakesAvailable || program.intakeOffered || 'NOT_FOUND';
                    const admDeadline = program.admissionDeadline_found || program.applicationDeadline || deadline || 'NOT_FOUND';
                    const casDeadline = program.casSubmissionDeadline_found || program.casDeadline || 'NOT_FOUND';
                    const i20Deadline = program.i20Deadline_found || program.i20Deadline || 'NOT_FOUND';
                    const intakeStatus = program.intakeStatus || 'NOT_FOUND';
                    const errMsg = program.errorMessage || '';
                    const checkDate = program.checkedDate || new Date().toISOString().split('T')[0];
                    const remarks = program.remarks || program.admissionAlerts || '';
                    
                    // Status badge styling
                    let statusBadge = '';
                    if (intakeStatus !== 'NOT_FOUND') {
                        const statusColor = intakeStatus === 'open' ? '#4caf50' : intakeStatus === 'closed' ? '#f44336' : intakeStatus === 'waitlist' ? '#ff9800' : '#999';
                        statusBadge = `<span style="background: ${statusColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600;">${intakeStatus.toUpperCase()}</span>`;
                    } else {
                        statusBadge = '<span style="color: #999;">NOT_FOUND</span>';
                    }
                    
                    html += `<tr ${rowClass}>`;
                    html += `<td>${srNum}</td>`;
                    html += `<td>${escapeHtml(uniName)}</td>`;
                    html += `<td>${escapeHtml(campusLoc)}</td>`;
                    html += `<td>${escapeHtml(progName)}</td>`;
                    html += `<td><a href="${escapeHtml(admUrl)}" target="_blank" style="color: #2196f3; text-decoration: underline;">${escapeHtml(admUrl.length > 50 ? admUrl.substring(0, 50) + '...' : admUrl || 'N/A')}</a></td>`;
                    html += `<td>${escapeHtml(intakesAvail)}</td>`;
                    // Application Deadline column - show the extracted deadline
                    const applicationDeadline = program.admissionDeadline || program.admissionDeadline_found || program.applicationDeadline || 'NOT_FOUND';
                    html += `<td style="font-weight: ${applicationDeadline !== 'NOT_FOUND' ? 'bold' : 'normal'}; color: ${applicationDeadline !== 'NOT_FOUND' ? '#2196f3' : '#999'};">${escapeHtml(applicationDeadline)}</td>`;
                    html += `<td>${escapeHtml(admDeadline)}</td>`;
                    html += `<td>${escapeHtml(casDeadline)}</td>`;
                    html += `<td>${escapeHtml(i20Deadline)}</td>`;
                    html += `<td>${statusBadge}</td>`;
                    html += `<td style="color: ${errMsg ? '#f44336' : '#4caf50'}; font-size: 12px;">${escapeHtml(errMsg)}</td>`;
                    html += `<td>${checkDate}</td>`;
                    html += `<td>${escapeHtml(remarks)}</td>`;
                    html += '</tr>';
                }

                tbody.innerHTML = html;
                updateProgress(100, `‚úÖ Sync complete! Processed ${processedCount} programs`);
                addStreamLine('success', `‚úÖ Sync Complete: ${successCount} successful, ${errorCount} errors`);
                addStreamLine('info', 'Data updated in table. You can download CSV to see all changes.');
                
                // Enable CSV download button after successful sync
                const downloadButton = document.querySelector('.download-button');
                if (downloadButton) {
                    downloadButton.disabled = false;
                    downloadButton.style.opacity = '1';
                    downloadButton.style.cursor = 'pointer';
                    addStreamLine('success', 'üì• CSV Download button is now enabled!');
                }
                
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 3000);

            } catch (error) {
                console.error('Sync error:', error);
                addStreamLine('error', `Sync failed: ${error.message}`);
                updateProgress(0, 'Sync failed');
            } finally {
                button.disabled = false;
                button.textContent = '‚ñ∂Ô∏è Step 3: Sync Now';
                updateButtonStates();
            }
        };
        window.downloadCSV = async function() {
            try {
                // Use programDataStore directly (data from sync)
                let dataToExport = programDataStore || [];
                
                if (dataToExport.length === 0) {
                    alert('No data available to export. Please run sync first.');
                    return;
                }
                const headers = ['Sr', 'universityName', 'Campus Location', 'programName', 'admissionsPageUrl', 'intakesAvailable', 'Application Deadline', 'admissionDeadline_found', 'casSubmissionDeadline_found', 'i20Deadline_found', 'intakeStatus', 'appended uni name', 'appended program name', 'appended campus name', 'errorMessage', 'checkedDate', 'syncDate', 'remarks'];
                const csvRows = [headers.join(',')];
                dataToExport.forEach((item, index) => {
                    const row = [
                        escapeCSV(item.sr || (index + 1)),
                        escapeCSV(item.universityName || item.university || ''),
                        escapeCSV(item.location || item.campusLocation || item.country || 'NOT_FOUND'),
                        escapeCSV(item.programName || item.program || ''),
                        escapeCSV(item.admissionsPageUrl || item.url || ''),
                        escapeCSV(item.intakesAvailable || item.intakeOffered || 'NOT_FOUND'),
                        escapeCSV(item.admissionDeadline || item.admissionDeadline_found || item.applicationDeadline || item.deadline || 'NOT_FOUND'),
                        escapeCSV(item.admissionDeadline_found || item.applicationDeadline || item.deadline || 'NOT_FOUND'),
                        escapeCSV(item.casSubmissionDeadline_found || item.casDeadline || 'NOT_FOUND'),
                        escapeCSV(item.i20Deadline_found || item.i20Deadline || 'NOT_FOUND'),
                        escapeCSV(item.intakeStatus || 'NOT_FOUND'),
                        escapeCSV(item.appendedUniName || ''),
                        escapeCSV(item.appendedProgramName || ''),
                        escapeCSV(item.appendedCampusName || ''),
                        escapeCSV(item.errorMessage || ''),
                        escapeCSV(item.checkedDate || new Date().toISOString().split('T')[0]),
                        escapeCSV(item.syncDate || new Date().toISOString()),
                        escapeCSV(item.remarks || item.admissionAlerts || '')
                    ];
                    csvRows.push(row.join(','));
                });
                const csvContent = csvRows.join('\n');
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const filename = `admissions-data-${year}-${month}-${day}-${hours}-${minutes}-${seconds}.csv`;
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                addStreamLine('success', `CSV downloaded: ${filename}`);
            } catch (error) {
                console.error('CSV download error:', error);
                addStreamLine('error', `CSV download failed: ${error.message}`);
                alert('Failed to download CSV. Please try again.');
            }
        };
        function escapeCSV(value) {
            if (value === null || value === undefined) return '';
            const stringValue = String(value);
            if (stringValue.includes(',') || stringValue.includes('"') || stringValue.includes('\n')) {
                return `"${stringValue.replace(/"/g, '""')}"`;
            }
            return stringValue;
        }

        // Extract university name, program name, and campus location from URL
        function extractNamesFromUrl(url) {
            const result = {
                extractedUniversityName: '',
                extractedProgramName: '',
                extractedCampusLocation: ''
            };
            
            try {
                if (!url || typeof url !== 'string') return result;
                
                const urlObj = new URL(url);
                const hostname = urlObj.hostname.toLowerCase();
                const pathname = urlObj.pathname.toLowerCase();
                const searchParams = urlObj.searchParams;
                
                // Extract university name from hostname (e.g., birmingham.ac.uk -> University of Birmingham)
                const domainParts = hostname.split('.');
                if (domainParts.length >= 2) {
                    const mainDomain = domainParts[0];
                    // Convert domain to readable name (e.g., birmingham -> Birmingham)
                    result.extractedUniversityName = mainDomain.charAt(0).toUpperCase() + mainDomain.slice(1);
                    
                    // Handle common patterns
                    if (mainDomain.includes('university') || mainDomain.includes('uni')) {
                        result.extractedUniversityName = mainDomain.replace(/[-_]/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }
                }
                
                // Extract program name from pathname
                // Common patterns: /study/.../program-name, /courses/.../program-name, /programs/.../program-name
                const pathSegments = pathname.split('/').filter(seg => seg && seg.length > 2);
                
                // Look for program name in path (usually the last meaningful segment)
                // Skip common words: study, courses, programs, postgraduate, undergraduate, subjects
                const skipWords = ['study', 'courses', 'programs', 'postgraduate', 'undergraduate', 'subjects', 'course', 'program', 'page', 'index', 'home'];
                
                for (let i = pathSegments.length - 1; i >= 0; i--) {
                    const segment = pathSegments[i];
                    if (!skipWords.includes(segment) && segment.length > 3) {
                        // Decode URL encoding and format
                        const decoded = decodeURIComponent(segment.replace(/-/g, ' '));
                        result.extractedProgramName = decoded.split(' ').map(word => 
                            word.charAt(0).toUpperCase() + word.slice(1)
                        ).join(' ');
                        break;
                    }
                }
                
                // Extract campus location from query params or path
                // Common params: location, campus, city
                const locationParam = searchParams.get('location') || searchParams.get('campus') || searchParams.get('city');
                if (locationParam) {
                    result.extractedCampusLocation = locationParam.split(' ').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                }
                
                // Also check path for campus/location info
                const locationInPath = pathname.match(/(?:campus|location|city)[\/\-]([^\/\?]+)/i);
                if (locationInPath && locationInPath[1]) {
                    result.extractedCampusLocation = decodeURIComponent(locationInPath[1]).replace(/-/g, ' ').split(' ').map(word => 
                        word.charAt(0).toUpperCase() + word.slice(1)
                    ).join(' ');
                }
                
                // Try to extract from page title or meta tags if available (will be done in extraction)
                
            } catch (error) {
                console.error('Error extracting names from URL:', error);
            }
            
            return result;
        }
        
        // Compare provided names with extracted names
        function compareNames(provided, extracted) {
            const normalize = (str) => {
                if (!str) return '';
                return str.toLowerCase().trim().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, ' ');
            };
            
            const providedNorm = normalize(provided);
            const extractedNorm = normalize(extracted);
            
            // Check if they're similar (allow for minor differences)
            if (providedNorm === extractedNorm) return true;
            
            // Check if one contains the other
            if (providedNorm.includes(extractedNorm) || extractedNorm.includes(providedNorm)) {
                return true;
            }
            
            // Check for common words match (at least 2 significant words match)
            const providedWords = providedNorm.split(' ').filter(w => w.length > 3);
            const extractedWords = extractedNorm.split(' ').filter(w => w.length > 3);
            const commonWords = providedWords.filter(w => extractedWords.includes(w));
            
            return commonWords.length >= 2;
        }

        // Extract data from HTML content using pattern matching
        function extractDataFromContent(htmlContent, programName, universityName, url) {
            const result = {
                admissionDeadline: 'NOT_FOUND',
                casDeadline: 'NOT_FOUND',
                i20Deadline: 'NOT_FOUND',
                intakesAvailable: 'NOT_FOUND',
                intakeStatus: 'NOT_FOUND', // DO NOT ASSUME - only set if explicitly found
                campusLocation: 'NOT_FOUND',
                remarks: '',
                errorMessage: ''
            };
            
            try {
                // HUMAN-LIKE READING: Extract ALL visible text like a human would scan the page
                let enhancedContent = htmlContent;
                
                // Step 1: Extract text from headings (humans read these first)
                const headings = htmlContent.match(/<h[1-6][^>]*>([^<]+)<\/h[1-6]>/gi);
                if (headings) {
                    headings.forEach(h => {
                        const text = h.replace(/<[^>]+>/g, '').trim();
                        if (text.length > 3) enhancedContent += ' HEADING: ' + text + ' ';
                    });
                }
                
                // Step 2: Extract from main content areas
                const mainContent = htmlContent.match(/<main[^>]*>([\s\S]*?)<\/main>/gi);
                if (mainContent) {
                    mainContent.forEach(m => {
                        enhancedContent += ' ' + m.replace(/<[^>]+>/g, ' ');
                    });
                }
                
                // Step 3: Extract from article/content sections
                const articles = htmlContent.match(/<article[^>]*>([\s\S]*?)<\/article>/gi);
                if (articles) {
                    articles.forEach(a => {
                        enhancedContent += ' ' + a.replace(/<[^>]+>/g, ' ');
                    });
                }
                
                // Step 4: Extract from paragraphs (main readable content)
                const paragraphs = htmlContent.match(/<p[^>]*>([^<]+)<\/p>/gi);
                if (paragraphs) {
                    paragraphs.forEach(p => {
                        const text = p.replace(/<[^>]+>/g, '').trim();
                        if (text.length > 10) enhancedContent += ' ' + text + ' ';
                    });
                }
                
                // Step 5: Extract from list items (often contain key details)
                const listItems = htmlContent.match(/<li[^>]*>([^<]+)<\/li>/gi);
                if (listItems) {
                    listItems.forEach(li => {
                        const text = li.replace(/<[^>]+>/g, '').trim();
                        if (text.length > 5) enhancedContent += ' ' + text + ' ';
                    });
                }
                
                // Step 6: Extract from divs with course/program/details classes
                // PRIORITIZE: Look for sections mentioning "India", "international", "overseas", "visa"
                const internationalSections = htmlContent.match(/<div[^>]*(?:class|id)=["'][^"']*(?:india|international|overseas|visa|country|location)[^"']*["'][^>]*>([\s\S]{10,1000})<\/div>/gi);
                if (internationalSections) {
                    internationalSections.forEach(section => {
                        const text = section.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                        if (text.length > 10) enhancedContent = ' INTERNATIONAL: ' + text + ' ' + enhancedContent; // Prioritize at the beginning
                    });
                }
                
                // Step 6b: Extract from divs with course/program/details classes
                const detailDivs = htmlContent.match(/<div[^>]*(?:class|id)=["'][^"']*(?:course|program|detail|info|date|deadline|intake|start|duration|study|mode|location|campus)[^"']*["'][^>]*>([\s\S]{10,500})<\/div>/gi);
                if (detailDivs) {
                    detailDivs.forEach(div => {
                        const text = div.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                        if (text.length > 10) enhancedContent += ' DETAILS: ' + text + ' ';
                    });
                }
                
                // Step 7: Extract from data attributes (structured data)
                const dataAttrs = htmlContent.match(/data-[^=]*="([^"]{10,200})"/gi);
                if (dataAttrs) {
                    dataAttrs.forEach(attr => {
                        const match = attr.match(/="([^"]+)"/);
                        if (match && match[1].length > 5) enhancedContent += ' DATA: ' + match[1] + ' ';
                    });
                }
                
                // Step 8: Extract from tables (structured information)
                const tableCells = htmlContent.match(/<t[dh][^>]*>([^<]+)<\/t[dh]>/gi);
                if (tableCells) {
                    tableCells.forEach(cell => {
                        const text = cell.replace(/<[^>]+>/g, '').trim();
                        if (text.length > 3) enhancedContent += ' TABLE: ' + text + ' ';
                    });
                }
                
                // Step 9: Extract from spans and labels (often contain key-value pairs)
                const spans = htmlContent.match(/<span[^>]*>([^<]{5,100})<\/span>/gi);
                if (spans) {
                    spans.forEach(span => {
                        const text = span.replace(/<[^>]+>/g, '').trim();
                        if (text.length > 5 && !text.match(/^[0-9\s]+$/)) enhancedContent += ' ' + text + ' ';
                    });
                }
                
                // Step 10: Extract from labels (often contain field names and values)
                const labels = htmlContent.match(/<label[^>]*>([^<]+)<\/label>/gi);
                if (labels) {
                    labels.forEach(label => {
                        const text = label.replace(/<[^>]+>/g, '').trim();
                        if (text.length > 3) enhancedContent += ' LABEL: ' + text + ' ';
                    });
                }
                
                // Enhanced HTML parsing: Extract content from tabs, dropdowns, and hidden elements
                
                // Extract content from hidden tabs
                const hiddenTabContent = htmlContent.match(/<div[^>]*(?:aria-hidden|display:\s*none|hidden|tab-pane|tab-content)[^>]*>([\s\S]*?)<\/div>/gi);
                if (hiddenTabContent) {
                    hiddenTabContent.forEach(tab => {
                        enhancedContent += ' ' + tab.replace(/<[^>]+>/g, ' ');
                    });
                }
                
                // Extract content from dropdowns/accordions
                const dropdownContent = htmlContent.match(/<div[^>]*(?:dropdown|accordion|collapse|expand)[^>]*>([\s\S]*?)<\/div>/gi);
                if (dropdownContent) {
                    dropdownContent.forEach(dropdown => {
                        enhancedContent += ' ' + dropdown.replace(/<[^>]+>/g, ' ');
                    });
                }
                
                // Extract content from data attributes
                const dataAttributes = htmlContent.match(/data-[^=]*="([^"]*)"/gi);
                if (dataAttributes) {
                    dataAttributes.forEach(attr => {
                        const match = attr.match(/="([^"]*)"/);
                        if (match) enhancedContent += ' ' + match[1];
                    });
                }
                
                // Remove script and style tags to get cleaner text
                const cleanContent = enhancedContent
                    .replace(/<script[^>]*>[\s\S]*?<\/script>/gi, ' ')
                    .replace(/<style[^>]*>[\s\S]*?<\/style>/gi, ' ')
                    .replace(/<[^>]+>/g, ' ')
                    .replace(/\s+/g, ' ')
                    .toLowerCase();
                
                // Extract intakes available - HUMAN-LIKE: Look for "Next start date", "Future start date", "Start date", etc.
                const intakePatterns = [
                    // "Next start date: Jan 2026" or "Future start date: Jan 2026"
                    /(?:next\s+start\s+date|future\s+start\s+date|start\s+date|intake\s+date|course\s+start)[\s:]*([^.!?\n]{0,100}(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|january|february|march|april|may|june|july|august|september|october|november|december|fall|spring|summer|winter|autumn)[^.!?\n]{0,50}\s*\d{4})/gi,
                    // "Jan 2026", "January 2026", "Fall 2024"
                    /(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|january|february|march|april|may|june|july|august|september|october|november|december|fall|spring|summer|winter|autumn)[a-z]*\s+\d{4}/gi,
                    // "2026/01", "2024-09", "2024/25"
                    /\d{4}[\/\-]\d{1,4}/g,
                    // "intake: September 2024" or "available: Fall 2024"
                    /(?:intake|intakes|available|offered|start)[\s:]*([^.!?\n]{0,200}(?:september|october|november|december|january|february|march|april|may|june|july|august|fall|spring|summer|winter|autumn|2024|2025|2026)[^.!?\n]{0,100})/gi,
                    // Multiple intakes: "Fall 2024, Spring 2025"
                    /(?:intake|intakes)[\s:]*([a-z0-9\s,]+(?:and|&|,)[a-z0-9\s,]+)/gi
                ];
                
                let intakesFound = [];
                for (const pattern of intakePatterns) {
                    const matches = cleanContent.match(pattern);
                    if (matches && matches.length > 0) {
                        matches.forEach(match => {
                            let intake = match.replace(/(?:intake|intakes|available|offered)[\s:]*/gi, '').trim();
                            if (intake && intake.length > 3 && intake.length < 100) {
                                intakesFound.push(intake);
                            }
                        });
                    }
                }
                
                // Search in highlighted/bolded text
                const highlightedText = htmlContent.match(/<(?:strong|b|em|mark|highlight)[^>]*>([^<]+)<\/(?:strong|b|em|mark|highlight)>/gi);
                if (highlightedText) {
                    highlightedText.forEach(highlight => {
                        const text = highlight.replace(/<[^>]+>/g, '').toLowerCase();
                        if (text.match(/(?:september|october|november|december|january|february|march|april|may|june|july|august|fall|spring|summer|winter|autumn|2024|2025|2026)/)) {
                            intakesFound.push(text);
                        }
                    });
                }
                
                // Remove duplicates and format
                intakesFound = [...new Set(intakesFound)];
                if (intakesFound.length > 0) {
                    result.intakesAvailable = intakesFound.slice(0, 3).join(', ');
                }
                
                // More comprehensive date patterns
                const datePatterns = [
                    // Format: "deadline: MM/DD/YYYY" or "deadline: DD/MM/YYYY"
                    /(?:application\s+deadline|admission\s+deadline|deadline|closing\s+date)[\s:]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/gi,
                    // Format: "deadline: January 15, 2024"
                    /(?:application\s+deadline|admission\s+deadline|deadline|closing\s+date)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    // Format: "15 January 2024"
                    /(?:application\s+deadline|admission\s+deadline|deadline)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    // Generic date patterns near deadline keywords
                    /(?:deadline|due\s+date|application\s+closes)[\s:]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/gi,
                    /(?:deadline|due\s+date|application\s+closes)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi
                ];
                
                // Search for admission deadline - PRIORITIZE international student deadlines
                // First, look for deadlines specifically for international students or India
                let deadlineFound = false;
                const internationalDeadlinePatterns = [
                    // Priority 1: "3 July 2026 Application deadline for international students requiring a visa" (date BEFORE text)
                    /(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})\s+application\s+deadline\s+for\s+international\s+students\s+requiring\s+a\s+visa/gi,
                    // Priority 2: "Application deadline for international students requiring a visa: 3 July 2026" (date AFTER text)
                    /(?:application\s+deadline\s+for\s+international\s+students\s+requiring\s+a\s+visa)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    // Priority 3: Other international student deadline patterns
                    /(?:application\s+deadline\s+for\s+international\s+students|deadline\s+for\s+international|international\s+student\s+deadline|deadline\s+for\s+india|india\s+deadline)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    /(?:application\s+deadline\s+for\s+international\s+students|deadline\s+for\s+international|international\s+student\s+deadline|deadline\s+for\s+india|india\s+deadline)[\s:]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/gi,
                    /(?:application\s+deadline\s+for\s+international\s+students\s+requiring\s+a\s+visa)[\s:]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/gi
                ];
                
                for (let i = 0; i < internationalDeadlinePatterns.length; i++) {
                    const pattern = internationalDeadlinePatterns[i];
                    const matches = cleanContent.match(pattern);
                    if (matches && matches.length > 0) {
                        // Extract the date from the match
                        let deadline = '';
                        
                        // For patterns with capturing groups (priority 1 and 2), use the captured group
                        if (i === 0 || i === 1) {
                            // These patterns have the date in a capturing group
                            const execResult = pattern.exec(cleanContent);
                            if (execResult && execResult[1]) {
                                deadline = execResult[1].trim();
                            }
                            // Reset regex lastIndex
                            pattern.lastIndex = 0;
                        } else {
                            // For other patterns, extract date from the match
                            const dateMatch = matches[0].match(/(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4}|\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/i);
                            if (dateMatch && dateMatch[1]) {
                                deadline = dateMatch[1].trim();
                            } else {
                                // Fallback: remove deadline text and keep the date
                                deadline = matches[0].replace(/(?:deadline|closing|application|admission|due\s+date|closes|for\s+international|for\s+india|requiring\s+a\s+visa)[\s:]*/gi, '').trim();
                            }
                        }
                        
                        if (deadline && deadline.match(/\d/)) {
                            result.admissionDeadline = deadline;
                            deadlineFound = true;
                            break;
                        }
                    }
                }
                
                // If no international-specific deadline found, use general patterns
                if (!deadlineFound) {
                    for (const pattern of datePatterns) {
                        const matches = cleanContent.match(pattern);
                        if (matches && matches.length > 0) {
                            // Take the first match and clean it
                            let deadline = matches[0].replace(/(?:deadline|closing|application|admission|due\s+date|closes)[\s:]*/gi, '').trim();
                            if (deadline) {
                                result.admissionDeadline = deadline;
                                deadlineFound = true;
                                break;
                            }
                        }
                    }
                }
                
                // If no deadline found, try to find any date near deadline-related text
                if (!deadlineFound) {
                    const contextPattern = /(?:deadline|application|admission|closing)[^.]{0,100}(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi;
                    const contextMatch = cleanContent.match(contextPattern);
                    if (contextMatch && contextMatch.length > 0) {
                        const dateMatch = contextMatch[0].match(/(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}|\d{1,2}\s+(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/i);
                        if (dateMatch) {
                            result.admissionDeadline = dateMatch[1].trim();
                            deadlineFound = true;
                        }
                    }
                }
                
                // Extract campus location
                const campusPatterns = [
                    /(?:campus|location|located\s+in|address)[\s:]*([^.!?]{0,100}(?:campus|university|college|building|street|avenue|road|city|town)[^.!?]{0,50})/gi,
                    /([A-Z][a-z]+\s+(?:Campus|University|College|Building|Street|Avenue|Road))/g,
                    /(?:at|in)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?\s+(?:Campus|University|College))/gi
                ];
                
                let campusFound = null;
                for (const pattern of campusPatterns) {
                    const matches = cleanContent.match(pattern);
                    if (matches && matches.length > 0) {
                        campusFound = matches[0].replace(/(?:campus|location|located\s+in|address|at|in)[\s:]*/gi, '').trim();
                        if (campusFound && campusFound.length > 3 && campusFound.length < 100) {
                            result.campusLocation = campusFound;
                            break;
                        }
                    }
                }
                
                // COMPREHENSIVE CAS deadline extraction (UK specific) - ALL possible formats
                const casPatterns = [
                    // Priority 1: Date BEFORE text: "3 July 2026 CAS deadline"
                    /(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})\s+(?:cas\s+deadline|cas\s+submission\s+deadline|confirmation\s+of\s+acceptance\s+for\s+studies)/gi,
                    // Priority 2: Date AFTER text: "CAS deadline: 3 July 2026"
                    /(?:cas\s+deadline|cas\s+submission\s+deadline|confirmation\s+of\s+acceptance\s+for\s+studies|cas)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    // Priority 3: Numeric formats
                    /(?:cas\s+deadline|cas\s+submission\s+deadline|cas)[\s:]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/gi,
                    // Priority 4: Short form "CAS: 3 July 2026"
                    /cas[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi
                ];
                
                let casFound = false;
                for (let i = 0; i < casPatterns.length; i++) {
                    const pattern = casPatterns[i];
                    const matches = cleanContent.match(pattern);
                    if (matches && matches.length > 0) {
                        // Extract date from match
                        let casDeadline = '';
                        if (i === 0) {
                            // Date comes first - extract it directly
                            const dateMatch = matches[0].match(/(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/i);
                            if (dateMatch && dateMatch[1]) {
                                casDeadline = dateMatch[1].trim();
                            }
                        } else {
                            // Date comes after text - extract from match
                            const execResult = pattern.exec(cleanContent);
                            if (execResult && execResult[1]) {
                                casDeadline = execResult[1].trim();
                            }
                            pattern.lastIndex = 0; // Reset regex
                        }
                        
                        if (casDeadline && casDeadline.match(/\d/)) {
                            result.casDeadline = casDeadline;
                            casFound = true;
                            break;
                        }
                    }
                }
                
                // COMPREHENSIVE I-20 deadline extraction (USA specific) - ALL possible formats
                const i20Patterns = [
                    // Priority 1: Date BEFORE text: "3 July 2026 I-20 deadline"
                    /(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})\s+(?:i-20\s+deadline|i20\s+deadline|form\s+i-20\s+deadline)/gi,
                    // Priority 2: Date AFTER text: "I-20 deadline: 3 July 2026"
                    /(?:i-20\s+deadline|i20\s+deadline|form\s+i-20\s+deadline|i-20\s+form|i-20\s+document)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi,
                    // Priority 3: Numeric formats
                    /(?:i-20|i20|form\s+i-20)[\s:]*(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})/gi,
                    // Priority 4: Short form "I-20: 3 July 2026"
                    /(?:i-20|i20)[\s:]*(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/gi
                ];
                
                let i20Found = false;
                for (let i = 0; i < i20Patterns.length; i++) {
                    const pattern = i20Patterns[i];
                    const matches = cleanContent.match(pattern);
                    if (matches && matches.length > 0) {
                        // Extract date from match
                        let i20Deadline = '';
                        if (i === 0) {
                            // Date comes first - extract it directly
                            const dateMatch = matches[0].match(/(\d{1,2}\s+(?:january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)[a-z]*\s+\d{2,4})/i);
                            if (dateMatch && dateMatch[1]) {
                                i20Deadline = dateMatch[1].trim();
                            }
                        } else {
                            // Date comes after text - extract from match
                            const execResult = pattern.exec(cleanContent);
                            if (execResult && execResult[1]) {
                                i20Deadline = execResult[1].trim();
                            }
                            pattern.lastIndex = 0; // Reset regex
                        }
                        
                        if (i20Deadline && i20Deadline.match(/\d/)) {
                            result.i20Deadline = i20Deadline;
                            i20Found = true;
                            break;
                        }
                    }
                }
                
                // INTAKE STATUS LOGIC - DO NOT ASSUME, ONLY USE EXPLICIT STATUS
                // Only set status if explicitly found on the page - otherwise leave as NOT_FOUND
                
                // Check for explicit "closed" indicators
                if (/(?:closed|not\s+accepting|no\s+longer\s+accepting|applications\s+closed|full|programme\s+is\s+full)/gi.test(cleanContent)) {
                    result.intakeStatus = 'closed';
                } 
                // Check for waitlist
                else if (/(?:waitlist|waiting\s+list|wait\s+list)/gi.test(cleanContent)) {
                    result.intakeStatus = 'waitlist';
                }
                // Check for explicit "open" indicators
                else if (/(?:open|accepting|now\s+accepting|currently\s+accepting|early\s+applications\s+encouraged|apply\s+early)/gi.test(cleanContent)) {
                    result.intakeStatus = 'open';
                }
                // If no explicit status found, leave as NOT_FOUND (do not assume)
                // DO NOT infer status from deadlines or other information
                
                // Extract any important notes/alerts
                const notePatterns = [
                    /(?:important\s+note|alert|warning|notice)[\s:]*([^.!?]{20,300})/gi,
                    /(?:early\s+application|apply\s+early|limited\s+seats|limited\s+availability)/gi
                ];
                
                for (const pattern of notePatterns) {
                    const matches = cleanContent.match(pattern);
                    if (matches && matches.length > 0) {
                        let note = matches[0].replace(/(?:important|note|alert|warning|notice)[\s:]*/gi, '').trim();
                        if (note && note.length > 10) {
                            result.remarks = note.substring(0, 200);
                            break;
                        }
                    }
                }
                
            } catch (error) {
                console.error('Extraction error:', error);
                result.errorMessage = `Extraction error: ${error.message}`;
            }
            
            return result;
        }

        // Escape HTML helper (if not already defined)
        if (typeof escapeHtml === 'undefined') {
            window.escapeHtml = function(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            };
        }
    </script>
</body>
</html>
<!-- Deployment trigger: 12/23/2025 12:53:37 -->
